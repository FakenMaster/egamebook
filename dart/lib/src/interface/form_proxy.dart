library egb_form_proxy;

import "../shared/form.dart";
import 'package:html5lib/dom.dart' as html5lib;
import "package:jsonml/jsonml2html5lib.dart";
import 'dart:async';

/**
 * Library that takes the Map generated by [Form.toMap()] and parses it. The
 * [EgbInterface] is then responsible for creating the actual form (for example,
 * by adding DOM elements to page) and listening to user input.
 */

class FormProxy extends FormBase {
  FormProxy.fromMap(Map<String,Object> map) {
    assert((map["jsonml"] as List)[0] == "Form");
    submitText = (map["jsonml"] as List)[1]["submitText"];
    createElementsFromJsonML(map["jsonml"]);
    FormConfiguration values = new FormConfiguration.fromMap(map["values"]);
    allFormElementsBelowThisOne.forEach((FormElement element) {
      Map<String,Object> elementValues = values.getById(element.id);
      if (elementValues != null) {
        (element as UpdatableByMap).updateFromMap(elementValues);
      }
    });
  }
  
  UiElement buildUiElements(Map<String,UiElementBuilder> builders) {
    return _recursiveCreateUiElement(builders, this);
  }
  
  Map<FormElement,UiElement> elementsMap = new Map<FormElement,UiElement>();
  UiElement _recursiveCreateUiElement(Map<String,UiElementBuilder> builders, 
                        FormElement element) {
    UiElement uiElement = builders[element.localName](element);
    elementsMap[element] = uiElement;
    if (uiElement.onInput != null) {
      uiElement.onInput.listen((_) {
        CurrentState state = _createCurrentState(disableEach: true,
            // Events from the Form UiElement itself are Submit events.
            submitted: uiElement == elementsMap[this]);  
        _streamController.add(state);
      });
    }
    for (FormElement child in element.formElementChildren) {
      UiElement childUiElement = _recursiveCreateUiElement(builders, child);
      uiElement.appendChild(childUiElement.uiRepresentation);
    }
    return uiElement;
  }
  
  /// Updates all elements according to the provided [config].
  void update(FormConfiguration config) {
    allFormElementsBelowThisOne.where((element) => element is UpdatableByMap)
    .forEach((FormElement element) {
      Map<String,Object> map = config.getById(element.id);
      if (map != null) {
        (element as UpdatableByMap).updateFromMap(map);
        elementsMap[element].update();
      }
    });
  }
  
  CurrentState _createCurrentState({bool submitted: false, 
    bool disableEach: false}) {
    CurrentState state = new CurrentState();
    allFormElementsBelowThisOne.where((element) => element is Input)
    .forEach((element) {
      state.add(element.id, (elementsMap[element] as Input).current);
      if (disableEach) {
        elementsMap[element].disabled = true;
      }
    });
    if (disableEach || submitted) {
      elementsMap[this].disabled = true;
    }
    state.submitted = submitted;
    return state;
  }
  
  StreamController<CurrentState> _streamController = 
        new StreamController<CurrentState>();
    Stream<CurrentState> get stream => _streamController.stream;
  
  void createElementsFromJsonML(List<Object> jsonml) {
    html5lib.Node node = decodeToHtml5Lib(jsonml, customTags: customTagHandlers,
        unsafe: true);
    children.addAll(node.children);
  }
}

typedef UiElement UiElementBuilder(FormElement elementBlueprint);

abstract class UiElement {
  UiElement(FormElement elementBlueprint);
  /// Updates the UiElement after the blueprint is changed. Sets
  /// [waitingForUpdate] back to [:false:].
  void update();
  /// Fired every time user interacts with Element and changes something.
  Stream get onInput;
  set disabled(bool value);
  bool get disabled;
  /// This is set to [:true:] after the user has interacted with the form and
  /// each [UiElement] in it should be disabled until [update] is called. This
  /// prevents user form setting the form's inputs into an invalid state.
  /// ([EgbScripter] always has a chance to act first, changing values,
  /// hiding inputs, disabling ranges, etc.)
  bool waitingForUpdate;
  /// This is the representation of the object in the UI. For HTML, this would
  /// be the [DivElement] that encompasses the [Form], or the [ParagraphElement]
  /// that materializes the [TextOutput]. 
  Object get uiRepresentation;
  void appendChild(Object childUiRepresentation);
}

Map<String,CustomTagHandler> customTagHandlers = {
  BaseRangeInput.elementClass: (Object jsonObject) {
    Map attributes = _getAttributesFromJsonML(jsonObject);
    return new InterfaceRangeInput(attributes["name"], attributes["id"]);
  }
};

Map<String,Object> _getAttributesFromJsonML(Object jsonObject) {
  return (jsonObject as List)[1] as Map<String,Object>;
}

class InterfaceRangeInput extends BaseRangeInput {
  InterfaceRangeInput(String name, String id) : super(name) {
    this.id = id;
  }
}