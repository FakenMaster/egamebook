<init>
  // TODO: create HandsCutOff and OneHandCutOff
  // TODO: weapons have pointer to the weapon they become when pirced
  // create new weapon: bare hands
  v_weaponHands = new WeaponType(
      name: "hand",
      piercing: 0,
      hardness: 0
  );

  // create new weapon: sword
  v_weaponSword = new WeaponType(
      name: "sword",
      piercing: 3,
      hardness: 3
  );

  // create new armor: clothes
  v_armorClothes = new ArmorType(
      name: "clothes",
      hardness: 0
  );

  v_armorHelmet = new ArmorType(
      name: "helmet",
      hardness: 1,
      coveringTargets: CombatMoveType.MOVE_TRG_HEAD
  );

  // move: foot sweep
  v_moveFootSweep = new CombatMoveType(
      type: CombatMoveType.MOVE_TRG_LEGS|CombatMoveType.MOVE_FRM_RIGHT
            |CombatMoveType.MOVE_LMB_LEG|CombatMoveType.MOVE_EFF_STANCE
            |CombatMoveType.MOVE_PRI_DAMAGE|CombatMoveType.MOVE_DIR_OFFENSIVE,
      string: "foot sweep",
      choiceString: "sweep <object's> feet",
      thirdPartyString: "<subject> undercut<s> <object's> legs",
      duration: 6,
      recovery: 4,
      stanceDamage: 25,
      baseChanceToDodge: 0.4,
      baseChanceToBlock: 0.2,
      fightingMod: -1
  );

  v_moveFootSweep.on["hit"].add((_this, e) {
      if (e.target.currentMove != null) {
        // TODO: report
        e.target.currentMove.on["cancel"].dispatchAll(new CombatEvent.fromMove(e.target.currentMove));
        e.target.currentMove = null;
      }
  });

  v_moveFootSweep.isApplicable = v_moveFootSweep.canContinue = (performer, target) {
    return performer.stance >= 10 && target.stance >= 20;
  };

  // TODO: sword weapon + 2 basic moves

  v_moveSlash = new CombatMoveType(
      type: CombatMoveType.MOVE_TRG_BODY|CombatMoveType.MOVE_FRM_RIGHT
            |CombatMoveType.MOVE_LMB_HAND|CombatMoveType.MOVE_EFF_HITPOINTS
            |CombatMoveType.MOVE_PRI_DAMAGE|CombatMoveType.MOVE_DIR_OFFENSIVE,
      string: "slash",
      choiceString: "slash <object's> body",
      thirdPartyString: "<subject> slash<es> <object's> body",
      duration: 5,
      recovery: 3,
      damage: 10,
      stanceDamage: 5,
      baseChanceToDodge: 0.4,
      baseChanceToBlock: 0.7,
      fightingMod: -1
  );

  // TODO: get rid of
  v_moveStomach = new CombatMoveType.Hand();
  v_moveLeftHook = new CombatMoveType.Haymaker();
  v_moveDefense = new CombatMoveType.Defense();
  v_moveStandUp = new CombatMoveType.StandUp();
  v_moveWithdraw = new CombatMoveType.Withdraw();

  v_humanMoves = [
      v_moveStomach,
      v_moveDefense,
      v_moveLeftHook,
      v_moveWithdraw,
      v_moveStandUp,
      v_moveFootSweep
  ];

  v_player = new Player();
  v_player.moves.addAll(v_humanMoves);
  v_player.weapon = v_weaponHands;
  //v_player.weapon = v_weaponSword;

  v_player.fighting = 1;
</init>


--- 
welcome

# Thin Ice System (TIS) Unit Testing



- Play [interactiveTest]
- Run tests [autoTest]

---
interactiveTest

You encounter a worthy opponent: a homeless man!

<dart>
  v_man = new Actor();
  v_man.moves.addAll(v_humanMoves);
  v_man.weapon = v_weaponHands;
  v_man.fighting = 0;
  v_man.names = ["the drunkard", "the drunk man", "the man"];
  v_man.on["sufferHit"].add((_this, e) { _this.report("<subject> looks very surprised"); });
  v_man.armors.add(v_armorHelmet);
</dart>

He charges at you!

<dart>
  v_combat = new Combat();
  v_combat.actors.addAll([ v_player, v_man ]);

  start(v_combat);
</dart>

And that''s the end of the fight!


---
autoTest

Asserting that more actors of the same type can take out less actors, most of the time.

<dart>
  v_NUMBER_OF_RUNS = 10;
  v_teamOneWins = 0;
  v_teamTwoWins = 0;

  Function runTest = () {
    v_swarmer1 = new Actor();
    v_swarmer1.names = ["the first swarmer"];
    v_swarmer1.pronoun = Pronoun.IT;
    v_swarmer1.moves.addAll(v_humanMoves);
    v_swarmer1.team = 2;

    v_swarmer2 = new Actor();
    v_swarmer2.names = ["the second swarmer"];
    v_swarmer2.pronoun = Pronoun.IT;
    v_swarmer2.moves.addAll(v_humanMoves);
    v_swarmer2.team = 2;

    v_swarmer3 = new Actor();
    v_swarmer3.names = ["the third swarmer"];
    v_swarmer3.pronoun = Pronoun.IT;
    v_swarmer3.moves.addAll(v_humanMoves);
    v_swarmer3.team = 2;

    v_individual1 = new Actor();
    v_individual1.names = ["the first individual"];
    v_individual1.moves.addAll(v_humanMoves);
    v_individual1.team = 3;

    v_individual2 = new Actor();
    v_individual2.names = ["the second individual"];
    v_individual2.moves.addAll(v_humanMoves);
    v_individual2.team = 3;

    v_combat = new Combat();
    v_combat.actors.addAll([v_individual1, v_swarmer1, v_individual2, v_swarmer2, v_swarmer3]);
    v_combat.on["update"].add((combat) {
      if ((combat.time % 10) == 0)
        combat.storyline.add("it's 10 seconds later");
    });
    v_combat.start();
    v_combat.updateUntilInteraction();

    assert(v_combat.finished);
    assert((!v_swarmer1.alive && !v_swarmer2.alive && !v_swarmer3.alive) 
          || (!v_individual1.alive && !v_individual2.alive));

    DEBUG(v_combat.storyline.toString());

    if (v_individual1.alive || v_individual2.alive)
      v_teamTwoWins++;
    else
      v_teamOneWins++;
  };

  for (int i = 0; i < v_NUMBER_OF_RUNS; i++)
    runTest();
  DEBUG("Swarm vs Individual: ${vars['teamOneWins']} : ${vars['teamTwoWins']}");
  assert(v_teamOneWins > v_teamTwoWins);

  int countBelow = 0;
  for (int i = 0; i < 1000; i++) {
    double random = Math.random();
    if (random < 0.1)
      countBelow++;
  }
  DEBUG("There were $countBelow throws that resulted with less than 0.1.");
  assert(countBelow < 500);
  assert(countBelow < 200);

</dart>

---
playable

<dart>
  v_wolf = new Actor();
  v_wolf.names = ["the orcling", "the orcling", "the young orcling"];
  v_wolf.pronoun = Pronoun.IT;
  v_wolf.moves.addAll(v_humanMoves);
  v_wolf.hitpoints = 2;
  v_wolf.speed = 1;

  v_orc = new Actor();
  v_orc.names = ["the orc", "the big orc", "the ugly orc"];
  v_orc.moves.addAll(v_humanMoves);
  v_combat = new Combat();
  v_combat.actors.addAll([v_wolf, v_orc,v_player]);
  v_combat.on["update"].add((combat) {
    if ((combat.time % 10) == 5)
      combat.storyline.add("a lonely bird beeps in the distance");
  });
  start(v_combat);
</dart>

<dart>
  if (!v_player.alive)
    goto(1);
</dart>

Congratulations! You beat your first enemies!


---
die

You died like the bitch you are.



<classes>

void DEBUG(String str) {
  print(str);
}

int GLOBAL_HASH_I = 0;

Dynamic randomly(List choices) {
  num number = choices.length;
  if (number == 0)
    throw new Exception("Cannot randomly choose from an empty set.");
  double portionSize = 1.0 / number;
  double rand = Math.random();
  int which = (rand / portionSize).floor().toInt();

  return choices[which];
}

// from http://en.wikipedia.org/wiki/Hamming_weight
int countBits(int x) {
  int count;
  for (count=0; x > 0; count++)
      x &= x - 1;
  return count;
}

String capitalize(String str) {
  String firstLetter = str[0].toUpperCase();
  if (str.length == 1)
    return firstLetter;
  else 
    return "$firstLetter${str.substring(1)}";
}

class Pronoun {
  // see http://en.wikipedia.org/wiki/Latin_declension
  final String nominative; // He (kdo? co?)
  // vocative // not used
  final String accusative; // Him (koho? co?)
  final String genitive;   // His (koho? ceho?)
  // dative // not used
  // ablative
  // locative

  String toString() => nominative;

  const Pronoun(this.nominative, this.accusative, this.genitive); 

  static final Pronoun YOU = const Pronoun("you", "you", "your");
  static final Pronoun HE = const Pronoun("he", "him", "his");
  static final Pronoun SHE = const Pronoun("she", "her", "her");
  static final Pronoun IT = const Pronoun("it", "it", "its");
}

class Storyline {
  StringBuffer strBuf;
  List<Map<String,Dynamic>> reports;

  static final String SUBJECT = "<subject>";
  static final String SUBJECT_POSSESIVE = "<subject's>";
  static final String OBJECT = "<object>";
  static final String OBJECT_POSSESIVE = "<object's>";
  static final String SUBJECT_PRONOUN = "<subjectPronoun>";
  static final String SUBJECT_PRONOUN_POSSESIVE = "<subjectPronoun's>";
  static final String OBJECT_PRONOUN = "<objectPronoun>";
  static final String OBJECT_PRONOUN_POSSESIVE = "<objectPronoun's>";
  static final String ACTION = "<action>";
  static final String VERB_S = "<s>";
  static final String VERB_ES = "<es>"; // e.g. in "goes"
  static final String VERB_IES = "<ies>"; // e.g. in "tries", "flies"
  static final String VERB_DO = "<does>";
  static final String VERB_BE = "<is>";

  Storyline add(String str, [Actor subject, Actor object, bool but=false, bool positive=false, bool negative=false, bool endSentence=false, bool startSentence=false, bool wholeSentence=false]) {
    reports.add( {
        "string": str,
        "subject": subject,
        "object": object,
        "but": but,
        "positive": positive,
        "negative": negative,
        "endSentence": endSentence,
        "startSentence": startSentence,
        "wholeSentence": wholeSentence
    });
  }

  String string(int i) {
    if (i < 0 || i >= reports.length)
      return null;
    else
      return reports[i]["string"];
  }
  Actor subject(int i) {
    if (i < 0 || i >= reports.length)
      return null;
    else
      return reports[i]["subject"];
  }
  Actor object(int i) {
    if (i < 0 || i >= reports.length)
      return null;
    else
      return reports[i]["object"];
  }

  /// taking care of all the exceptions and rules when comparing different reports
  /// call: [: same('subject', i, i+1) ... :]
  bool same(String key, int i, int j) {
    if (!valid(i) || !valid(j))
      return false;
    if (reports[i][key] == null || reports[j][key] == null)
      return false;
    if (reports[i][key] == reports[j][key])
      return true;
    else
      return false;
  }

  bool exchanged(String key1, String key2, int i, int j) {
    if (!valid(i) || !valid(j))
      return false;
    if (reports[i][key1] == null || reports[j][key1] == null)
      return false;
    if (reports[i][key2] == null || reports[j][key2] == null)
      return false;
    if (reports[i][key1] == reports[j][key2]
     && reports[i][key2] == reports[j][key1])
      return true;
    else
      return false;
  }

  bool valid(int i) {
    if (i >= reports.length || i < 0)
      return false;
    else
      return true;
  }

  bool sameSentiment(int i, int j) {
    if (!valid(i) || !valid(j))
      return false;
    // subject(i) == object(j), opposite sentiments => same sentiment
    if (exchanged('subject', 'object', i, j) && subject(i).team != subject(j).team) {
      if (reports[i]["positive"] && reports[j]["negative"])
        return true;
      if (reports[i]["negative"] && reports[j]["positive"])
        return true;
    }
    if (!same('subject', i, j))
      return false;
    if (reports[i]["positive"] && reports[j]["positive"])
      return true;
    if (reports[i]["negative"] && reports[j]["negative"])
      return true;
    else
      return false;
  }

  bool oppositeSentiment(int i, int j) {
    if (!valid(i) || !valid(j))
      return false;
    // subject(i) == object(j), both have same sentiment => opposite sentiment
    if (exchanged('subject', 'object', i, j) && subject(i).team != subject(j).team) {
      if (reports[i]["positive"] && reports[j]["positive"])
        return true;
      if (reports[i]["negative"] && reports[j]["negative"])
        return true;
    }
    if (!same('subject', i, j))
      return false;
    if (reports[i]["positive"] && reports[j]["negative"])
      return true;
    if (reports[i]["negative"] && reports[j]["positive"])
      return true;
    else
      return false;
  }

  /// makes sure the sentence flows well with the previous sentence(s), then calls getString to do in-sentence substitution
  String substitute(int i, String str, [bool useSubjectPronoun=false, bool useObjectPronoun=false]) {
    String result = str.replaceAll(ACTION, string(i));
    if (useObjectPronoun || same('object', i, i-1)) {// if doing something to someone in succession, use pronoun
      result = result.replaceAll(OBJECT, object(i).pronoun.accusative);
      result = result.replaceAll(OBJECT_POSSESIVE, object(i).pronoun.genitive);
    }
    if (useSubjectPronoun || same('subject', i, i-1)) {
      result = result.replaceAll(SUBJECT, subject(i).pronoun.nominative);
      result = result.replaceAll(SUBJECT_POSSESIVE, subject(i).pronoun.genitive);
    }
    // if someone who was object last sentence is now subject (and it's not misleading), use pronoun
    if (object(i-1) != null && subject(i) != null && subject(i-1) != null
        && object(i-1) == subject(i) && subject(i-1).pronoun != subject(i).pronoun) {
      result = result.replaceAll(SUBJECT, subject(i).pronoun.nominative);
      result = result.replaceAll(SUBJECT_POSSESIVE, subject(i).pronoun.genitive);
    }
    // same as previous, but with object-subject reversed
    if (subject(i-1) != null && object(i) != null && subject(i-1) != null
        && subject(i-1) == object(i) && subject(i-1).pronoun != subject(i).pronoun) {
      result = result.replaceAll(OBJECT, object(i).pronoun.accusative);
      result = result.replaceAll(OBJECT_POSSESIVE, object(i).pronoun.genitive);
    }
    return getString(result, subject(i), object(i));
  }

  /// Takes care of substitution of stopwords. Called by substitute().
  static String getString(String str, [Actor subject, Actor object]) {
    String result = str;
    if (subject != null) {
      if (subject.pronoun == Pronoun.YOU) { // don't talk like a robot: "player attacks wolf"
        result = result.replaceAll(SUBJECT, subject.pronoun.nominative);
        result = result.replaceAll(SUBJECT_POSSESIVE, subject.pronoun.genitive);
        result = result.replaceAll(VERB_S, "");
        result = result.replaceAll(VERB_ES, "");
        result = result.replaceAll(VERB_IES, "y");
        result = result.replaceAll(VERB_DO, "do");
        result = result.replaceAll(VERB_BE, "are");
      }
      else { // third person
        result = result.replaceFirst(SUBJECT, subject.name);
        result = result.replaceAll(SUBJECT, subject.pronoun.nominative);
        result = result.replaceAll(VERB_S, "s");
        result = result.replaceAll(VERB_ES, "es");
        result = result.replaceAll(VERB_IES, "ies");
        result = result.replaceAll(VERB_DO, "does");
        result = result.replaceAll(VERB_BE, "is");
      }
      result = result.replaceAll(SUBJECT_PRONOUN, subject.pronoun.nominative);
      if (str.indexOf(SUBJECT) < str.indexOf(SUBJECT_POSSESIVE)) { // "actor takes his weapon"
        result = result.replaceAll(SUBJECT_POSSESIVE, subject.pronoun.genitive);
      }
      result = result.replaceFirst(SUBJECT_POSSESIVE, "${subject.name}'s");
      result = result.replaceAll(SUBJECT_POSSESIVE, subject.pronoun.genitive);
      result = result.replaceAll(SUBJECT_PRONOUN_POSSESIVE, subject.pronoun.genitive);
    }
    if (object != null) {
      if (object.isPlayer) { // don't talk like a robot: "wolf attacks player"
        result = result.replaceAll(OBJECT, object.pronoun.accusative);
        result = result.replaceAll(OBJECT_POSSESIVE, object.pronoun.genitive);
      } else
        result = result.replaceAll(OBJECT, object.name);
      result = result.replaceAll(OBJECT_PRONOUN, object.pronoun.accusative);
      if (str.indexOf(OBJECT) < str.indexOf(OBJECT_POSSESIVE)) { // "actor takes his weapon"
        result = result.replaceAll(OBJECT_POSSESIVE, object.pronoun.genitive);
      }
      result = result.replaceFirst(OBJECT_POSSESIVE, "${object.name}'s");
      result = result.replaceAll(OBJECT_POSSESIVE, object.pronoun.genitive);
      result = result.replaceAll(OBJECT_PRONOUN_POSSESIVE, object.pronoun.genitive);
    }

    return result;
  }

  Storyline() {
    reports = new List<Map<String,Dynamic>>();
    strBuf = new StringBuffer();
  }

  void clear() {
    reports.clear();
    strBuf.clear();
  }

  /// The main function that strings reports together into a coherent story.
  String toString() {
    final int length = reports.length;
    if (length < 1)
      return "";
    final int MAX_SENTENCE_LENGTH = 3;
    int lastEndSentence = -1;
    bool endSentence = true; // previous sentence was ended
    bool endSentenceNeeded = false; // this sentence needs to be ended
    bool but = false; // this next sentence needs to start with but
    for (int i=0; i < length; i++) {
      // TODO: look into future - make sentences like "Although __, __"
      if (i != 0) {
        // solve flow with previous sentence
        bool objectSubjectSwitch = 
                 reports[i-1]["subject"] == reports[i]["object"]
              && reports[i-1]["object"] == reports[i]["subject"];
        but = reports[i]["but"] || oppositeSentiment(i, i-1);
        endSentence = 
          (i - lastEndSentence >= MAX_SENTENCE_LENGTH) 
          || endSentenceNeeded
          || reports[i]["startSentence"] 
          || reports[i-1]["endSentence"] 
          || reports[i]["wholeSentence"]
          || !(same('subject', i, i-1) || objectSubjectSwitch)
          || (but && (i - lastEndSentence > 1));
        endSentenceNeeded = false;

        // DEBUG("SENT: ${string(i)}\n- whole=${reports[i]["endSentence"]}
        if (endSentence) {
          if (reports[i-1]["wholeSentence"]) // don't write period after "Boom!"
            strBuf.add(" ");
          else
            strBuf.add(". ");
          if (but && !reports[i]["wholeSentence"])
            strBuf.add(randomly(["But ", "But ", "However, ", "Nonetheless, ", "Nevertheless, "]));
        } else { // let's try and glue [i-1] and [i] into one sentence
          if (but) {
            strBuf.add(randomly([" but ", " but ", " yet ", ", but "]));
            if (!sameSentiment(i, i+1))
              endSentenceNeeded = true;
          } else {
            if (same('subject', i, i-1) && string(i).startsWith("$SUBJECT ")
                && i < length - 1  && i - lastEndSentence < MAX_SENTENCE_LENGTH - 1) {
              strBuf.add(", ");
            } else {
              strBuf.add(randomly([" and ", " and ", ", and "]));
              endSentenceNeeded = true;
            }
          }
        }
      }

      String report = string(i);
      // clear subjects when e.g. "Wolf hits you, it growls, it strikes again."
      if (!endSentence)
        if (same('subject', i, i-1))
          if (string(i-1).startsWith("$SUBJECT "))
            if (report.startsWith("$SUBJECT "))
              report = report.replaceFirst("$SUBJECT ", "");

      report = substitute(i, report);

      if ((endSentence || i == 0) && !but)
        report = capitalize(report);

      // add the actual report
      strBuf.add(report);

      // set variables for next iteration
      if (endSentence)
        lastEndSentence = i;
      if (reports[i]["wholeSentence"])
        endSentenceNeeded = true;
    }

    // add last dot
    if (!reports[length-1]["wholeSentence"])
      strBuf.add(".");

    return strBuf.toString();
  }
}

class GameEntity implements Hashable {
  List <String> names;
  Pronoun pronoun = Pronoun.IT;

  GameEntity() {
    names = new List();
  }
  
  int hashCode() {
    return GLOBAL_HASH_I++;
  }

  String get name() => randomly(names);
}

/**
  Actor class: an independent actor in the GameEvent, such as Combat.
  */
class Actor extends GameEntity {
  // current state
  bool alive = true;
  bool isPlayer = false;
  int team = 2; // actors are on team 2 (Enemy) by default
  int _hitpoints;
  // from 0 = lying on the ground to 50 = professional combat stance
  // 0=lying, 10=on_knees, 20=almost_falling, 30=shaken, 40=firm_stance, 50=pro_stance
  int _stance;  
  List<String> stanceUpStrings;
  List<String> stanceDownStrings;
  List<CombatMoveType> moves;
  CurrentCombatMove _currentMove;
  CombatMoveType previousMove; // keeps track of previous move's type so that actors don't do the same thing over and over again
  WeaponType weapon;
  Set<ArmorType> armors;

  int tillEndOfMove = 0;
  bool recoveringFromMove = false;

  Combat combat;
  Actor _target;

  CombatCallbackHandler on;

  // an utility function that prints to the combat's storyline, pre-filling this actor as the subject
  void report(String str, [Actor subject, Actor object, bool but=false, bool positive=false, bool negative=false, bool endSentence=false, bool startSentence=false, bool wholeSentence=false, bool reportOnlyOnAlive=true]) {
    if (combat == null)
      return;
    if (subject == null)
      subject = this;
    if (!subject.alive && reportOnlyOnAlive)
      return;
    combat.storyline.add(str, subject:subject, object:object, but:but, positive:positive, negative:negative, endSentence:endSentence, startSentence:startSentence, wholeSentence:wholeSentence);
  }

  /// returns the fighting ability modified by current move and stance
  int get modifiedFighting() {
    int stanceMod = Math.max((((29 - _stance) / 10) + 1), 0).toInt(); // stance 0-9 => -3, stance 10-19 => -2, 20-29 => -1. Stance 30+ => no mod
    int hitpointsMod = Math.max(0, (((maxHitpoints - _hitpoints)/maxHitpoints - 0.7) * 10)).toInt(); // if hitpoint are below 20% of maxHitpoint => -1, below 10% => -2
    if (currentMove == null)
      return fighting - stanceMod - hitpointsMod;
    else
      return fighting - stanceMod - hitpointsMod + currentMove.type.fightingMod;
  }

  int get modifiedBlocking() => modifiedFighting + weapon.blockingMod;
  int get modifiedDodging() {
    int value = modifiedFighting;
    for (ArmorType armor in armors) {
      value += armor.dodgingMod;
    }
    return value;
  }

  CurrentCombatMove get currentMove() => _currentMove;
  void set currentMove(CombatMoveType value) { // TODO: fix class mismatch
    if (_currentMove != null)
      previousMove = _currentMove.type;
    if (value == null) {
      if (_currentMove != null) {
        tillEndOfMove = _currentMove.type.recovery; // do not substract speed from recovery - this makes speed too powerful
        if (tillEndOfMove > 0)
          recoveringFromMove = true;
      }

      _currentMove = null;
    } else {
      _currentMove = new CurrentCombatMove(value, this, target);
      tillEndOfMove = _currentMove.type.duration - (Math.random() * 2).round().toInt(); // duration will vary slightly (TODO: TBD)
      _currentMove.on["start"].dispatchAll(new CombatEvent.fromMove(_currentMove));
    }
  }

  int get hitpoints() => _hitpoints;
  void set hitpoints(int value) {
    if (value <= 0) {
      on["die"].dispatchAll();
      alive = false;
      return;
    }

    if (value < _hitpoints) {
      on["hitpointsDown"].dispatchAll();
      if (currentMove != null)
        currentMove.on["hitpointsDown"].dispatchAll();
    } else if (value > _hitpoints) {
      on["hitpointsUp"].dispatchAll();
      if (currentMove != null)
        currentMove.on["hitpointsUp"].dispatchAll();
    }

    int almostDyingThreshold = Math.min(3, (maxHitpoints / 3).toInt());
    if (_hitpoints > almostDyingThreshold
        && value < almostDyingThreshold) {
      on["almostDying"].dispatchAll();
    }
    _hitpoints = Math.min(value, maxHitpoints);
  }

  int get stance() => _stance;
  void set stance(int value) {
    if (!alive)
      return;
    int prevStance = _stance;
    _stance = Math.min(value, maxStance);
    _stance = Math.max(0, _stance);
    // only report when stance is changed between levels
    if ((_stance / 10).toInt() != (prevStance / 10).toInt()) {
      if (_stance > prevStance) {
        report(stanceUpStrings[Math.min(5, (_stance / 10).toInt())], positive:true);
        on["stanceUp"].dispatchAll();
        if (currentMove != null)
          currentMove.on["stanceUp"].dispatchAll();
      } else {
        report(stanceDownStrings[Math.min(5, (_stance / 10).toInt())], negative:true);
        on["stanceDown"].dispatchAll();
        if (currentMove != null)
          currentMove.on["stanceDown"].dispatchAll();
        if (prevStance - _stance > 10 && _stance < 10) // damage from fall
          hitpoints -= 1;
      }
    }
  }

  Actor get target() => _target;
  void set target(Actor value) {
    _target = value;
    previousMove = null;
  }

  static void defaultOnAlmostDying(Actor _this) {
    // TODO: get rid of or make more generic
    _this.on["update"].add((Actor a) {
        if (a.combat.time % 12 == 6)
          if (randomly([true, false]))
            a.report("blood is dripping into <subject's> eyes", negative:true);
    });
    _this.report("<subject> <is> badly hurt", negative:true);
  }

  static void defaultOnDie(Actor _this) {
    _this.report("<subject> ${randomly(['pass<es> out','lose<s> consciousness','black<s> out','go<es> down'])}", negative:true, reportOnlyOnAlive:false);
  }

  // Ctor.
  Actor() : super() {
    on = new CombatCallbackHandler(this);
    weapon = new WeaponType();
    armors = new Set<ArmorType>();

    // init with defaults
    names = ["actor"];
    pronoun = Pronoun.HE;
    _hitpoints = maxHitpoints;
    _stance = maxStance;

    moves = new List();
    stanceUpStrings = const [
        "",  // no need for this string - nowhere to stand up from
        "<subject> get<s> to <subjectPronoun's> knees",
        "<subject> stand<s> up",
        "<subject> regain<s> some balance",
        "<subject's> stance gets firm",
        "<subject> go<es> into a perfect combat stance" 
    ];
    stanceDownStrings = const [
        "<subject> fall<s> to the ground",
        "<subject> fall<s> to <subjectPronoun's> knees",
        "<subject> <is> almost ready to fall",
        "<subject> get<s> off balance",
        "<subject> lose<s> <subjectPronoun's> professional stance",
        "" // no need for this string (yet?) - nowhere to fall from
    ];

    on["almostDying"].add(defaultOnAlmostDying);
    on["die"].add(defaultOnDie);
  }

  /// Main update function of the Actor. This is where most
  /// of the action takes place.
  void update() {
    if (!alive)
      return;

    on["update"].dispatchAll();

    // make sure actor doesn't move after being poisoned to death 
    // in on["update"] above, for example
    if (!alive) 
      return;

    tillEndOfMove--; // just let the time pass

    if (tillEndOfMove > 0 && currentMove != null) {
      // move still in progress
      CombatEvent e = new CombatEvent.fromMove(currentMove);
      if (target != null && !target.alive && currentMove.type.isOffensive) {
        // actor is already dead and we're doing an offensive move
        currentMove.on["cancel"].dispatchAll(e);
        currentMove = null;
        target = null;
        return;
      } else {
        if (currentMove.type.canContinue(this, target)) {
          currentMove.on["update"].dispatchAll(e);
        } else {
          // move is no longer applicable
          currentMove.on["cancel"].dispatchAll(e);
          currentMove = null;
          return;
        }
      }
    } else if (tillEndOfMove <= 0) {
      // effect of finished move
      if (currentMove != null) {
        CombatEvent e = new CombatEvent.fromMove(currentMove);
        if (currentMove.type.canContinue(this, target)) {
          if (currentMove.type.isOffensive) {
            // throws
            double chance = currentMove.type.chanceToDodge(this, target);
            e.chance = chance;
            e.chanceAll = 1 - chance;
            if (Math.random() < chance) {
              DEBUG("- dodge success");
              // DODGED
              e.chanceAll = 1 - e.chanceAll;
              // TODO: implement Luck
              target.on["dodge"].dispatchAll(e); 
              currentMove.on["sufferDodge"].dispatchAll(e); // main
              this.on["sufferDodge"].dispatchAll(e);
              currentMove = null;
              return;
            } else {
              DEBUG("- dodge fail");
              // same as above, but for blocks
              chance = currentMove.type.chanceToBlock(this, target);
              e.chance = chance;
              e.chanceAll = e.chanceAll * (1 - chance);
              if (Math.random() < chance) {
                DEBUG("- block success");
                // BLOCKED
                e.chanceAll = 1 - e.chanceAll;
                // TODO: implement Luck
                currentMove.on["sufferMeetWeapon"].dispatchAll(e);
                if (target.weapon.hardness >= this.weapon.piercing) {
                  currentMove.on["sufferBlock"].dispatchAll(e); // main
                } else {
                  // blocking weapon is too weak and breaks
                  target.weapon.on["sufferPierced"].dispatchAll(e);
                  if (target.weapon.weaponWhenPierced != null)
                    target.weapon = target.weapon.weaponWhenPierced;
                  else
                    DEBUG("Warning: weapon ${target.weapon.name} doesn't have 'weaponWhenPierced' defined.");
                }
                target.on["block"].dispatchAll(e);
                this.on["sufferBlock"].dispatchAll(e);
                currentMove = null;
                return;
              } else {
                DEBUG("- block fail => hit");
                // HIT
                e.chance = 1 - e.chance;

                bool stoppedByArmor = false;
                for (ArmorType armor in target.armors) {
                  if (!currentMove.type.isOfType(armor.coveringEffects))
                    continue;  // armor has no effect here
                  if (!currentMove.type.isOfType(armor.coveringTargets))
                    continue;  // armor doesn't cover the target of this move
                  if (!currentMove.type.isOfType(armor.coveringSides))
                    continue;  // armor doesn't cover the side of this move

                  if (currentMove.type.isHitpointsDamaging) {
                    if (armor.hardness > this.weapon.piercing) {
                      // DEFLECT
                      stoppedByArmor = true;
                      e.armor = armor;
                      currentMove.on["sufferDeflect"].dispatchAll(e); // main
                      armor.on["deflect"].dispatchAll(e);
                      target.on["deflect"].dispatchAll(e);
                      this.on["sufferDeflect"].dispatchAll(e);
                      break;
                    }
                  }
                  // TODO: armor against stance damage?
                }
                if (!stoppedByArmor) {
                  // HIT PROPER
                  // TODO: implement Luck
                  currentMove.on["hit"].dispatchAll(e); // main
                  target.on["sufferHit"].dispatchAll(e);
                  if (target.currentMove != null)
                    target.currentMove.on["sufferHit"].dispatchAll(e);
                  this.on["hit"].dispatchAll(e);
                }
                currentMove = null;
                return;
              }
            }
          } else {
            // non-offensive move ended
            currentMove.on["end"].dispatchAll();
            currentMove = null;
            return;
          }
        } else {
          // cannot continue
          currentMove.on["cancel"].dispatchAll();
          currentMove = null;
          return;
        }
      }
      // AI
      if (!isPlayer) {
        if (target == null || !target.alive) {
          List<Actor> possibleEnemies = combat.actors.filter((o) => o.team != team && o.alive);
          if (!possibleEnemies.isEmpty())
            target = randomly(possibleEnemies);
          else {
            alive = false; // TODO: more elegant way to make sure combats don't wage forever
            return;
          }
        }

        if (target == null || !moves.some((m) => m.isApplicable(this,target)) ) {
          // no target or no combat moves applicable to the target, TODO: try to change target?
          report('<subject> ${randomly(["just stands there", "doesn\'t do anything", "does nothing"])}');
        } else {
          currentMove = chooseMove();
        }
      }
    }
  }

  // List moves
  List<CombatMoveType> getPossibleMoves([int max=1000]) {
    List<CombatMoveType> possibleMoves = moves.filter((m) => m.isApplicable(this,target));
    if (possibleMoves.length < 2)
      return possibleMoves;

    // first, sort by suitability (computeSuitability contains logic against repeating last move)
    possibleMoves.sort((a,b) => b.computeSuitability(this,target) - a.computeSuitability(this,target));
    // next, bring down moves that are already mostly covered by moves above them
    // bring down moves that have large countBits(type & previous.type) / countBits(type) (100% => same type of move)
    final double MAX_SIMILARITY = 0.70;
    Map<int,CombatMoveType> redundantMovesMap = new Map<int,CombatMoveType>();
    for (int i=1; i < possibleMoves.length; i++) {
      for (int j=0; j < i; j++) {
        double similarity = countBits(possibleMoves[i].type & possibleMoves[j].type) / countBits(possibleMoves[i].type);
        if (similarity > MAX_SIMILARITY) {
          redundantMovesMap[i] = possibleMoves[i];
          break;
        }
      }
    }
    // move redundant moves at the end of the list
    List<CombatMoveType> finalMoves = new List<CombatMoveType>(possibleMoves.length);
    int regularIndex = 0; int redundantIndex = possibleMoves.length - redundantMovesMap.length;
    for (int i = 0; i < possibleMoves.length; i++) {
      if (!redundantMovesMap.containsKey(i)) {
        finalMoves[regularIndex] = possibleMoves[i];
        regularIndex++;
      } else {
        finalMoves[redundantIndex] = possibleMoves[i];
        redundantIndex++;
      }
    }

    return finalMoves.getRange(0, Math.min(finalMoves.length, max)); // return up to max moves
  }

  // AI chooses a move
  CombatMoveType chooseMove([int max=1000]) {
    List<CombatMoveType> possibleMoves = getPossibleMoves(max:max);

    // logic that gives more chance to higher (more suitable) moves
    double random = Math.random();
    int pos;
    int len = possibleMoves.length; 
    int allParts = (len*(len+1)/2).toInt(); // 1+2+3+4+.. = allParts
    double part = 0.0;

    for (pos = 0; pos < len; pos++) {
      part += len - pos;
      if (random < part / allParts)
        break;
    }

    return possibleMoves[pos];
  }

  // stats
  int maxHitpoints = 10;
  int maxStance = 45; // the best stance this actor can muster
  int speed = 0; // 0 = normal person, -x = everything takes x seconds longer, +x = dtto shorter
  int fighting = 0; // 1 = normal person, +x = number of extra block/dodge throws per turn
  //int blocking = 0; // like fighting, but will be modified by weapon type
  //int dodging = 0; // like fighting, but will be modified by armor(s)
}

class Player extends Actor {
  Player() : super() {
    isPlayer = true;
    team = 1; // player is on team Player (1)
    names = ["player"];
    pronoun = Pronoun.YOU;
  }
}

/**
  CombatMoveType defines every type of movement, from a simple punch to elaborate
  sword-fight combos. Only one object of a type exists.
  */
class CombatMoveType extends GameEntity {
  /// the basic description of the move
  String string;
  /// the string to be presented as a choice to the player
  /// e.g.: "hit <object> to the stomach"
  String choiceString;
  /// e.g.: "hits <object> in the stomach"
  String thirdPartyString;

  int duration; // number of turns from start to effect (=hit)
  int recovery; // number of turns it gets to start a new move again
  int damage = 0;
  int stanceDamage = 0;
  double baseChanceToDodge = 0.0;
  double baseChanceToBlock = 0.0;

  // modifiers to move's performer. Many moves will make it temporarily harder to block and dodge
  // defense moves will make it easier (positive number)
  int fightingMod = 0;

  // type bits of the move
  int type = 0x0; // TODO: rename to typeBits? TBD.

  // target(s) of the move
  static final int MOVE_TRG_HEAD = 1<<1;
  static final int MOVE_TRG_NECK = 1<<2;
  static final int MOVE_TRG_ARMS = 1<<3;
  static final int MOVE_TRG_BODY = 1<<4;
  static final int MOVE_TRG_LEGS = 1<<5;
  static final int MOVE_TRG_ALL = MOVE_TRG_HEAD|MOVE_TRG_NECK|MOVE_TRG_ARMS|MOVE_TRG_BODY|MOVE_TRG_LEGS;

  // directions of the move
  static final int MOVE_FRM_FRONT = 1<<6;
  static final int MOVE_FRM_BEHIND = 1<<7;
  static final int MOVE_FRM_LEFT = 1<<8;
  static final int MOVE_FRM_RIGHT = 1<<9;
  static final int MOVE_FRM_ALL = MOVE_FRM_FRONT|MOVE_FRM_BEHIND|MOVE_FRM_LEFT|MOVE_FRM_RIGHT;

  // limbs used (primarily) for the move by the performer
  static final int MOVE_LMB_HAND = 1<<10;
  static final int MOVE_LMB_LEG = 1<<11;
  static final int MOVE_LMB_HEAD = 1<<12;
  static final int MOVE_LMB_SPECIAL = 1<<13; // e.g. tail

  // move damages {hitpoints|stance}?
  static final int MOVE_EFF_HITPOINTS = 1<<14;
  static final int MOVE_EFF_STANCE = 1<<15;
  static final int MOVE_EFF_ALL = MOVE_EFF_HITPOINTS|MOVE_EFF_STANCE;

  // priority: quicker or more damage?
  static final int MOVE_PRI_QUICK = 1<<16;
  static final int MOVE_PRI_DAMAGE = 1<<17;

  // defensive or offensive move
  static final int MOVE_DIR_OFFENSIVE = 1<<18;
  static final int MOVE_DIR_DEFENSIVE = 1<<19;

  // utility function. Returns true if this CombatMoveType is (at least partially) of type otherType.
  bool isOfType(int otherType) => (type & otherType) != 0;

  bool get isOffensive() => isOfType(MOVE_DIR_OFFENSIVE);
  bool get isHitpointsDamaging() => isOfType(MOVE_EFF_HITPOINTS);
  bool get isStanceDamaging() => isOfType(MOVE_EFF_STANCE);

  /// The events handler
  CombatCallbackHandler on;

  /// returns bool, whether this move is isApplicable given the two actors
  Function isApplicable;

  /// returns bool, whether this move can continue given the state
  Function canContinue;

  /// returns chance (0.0-1.0) of dodging this move
  Function chanceToDodge;

  /// returns chance (0.0-1.0) of blocking this move
  Function chanceToBlock;

  /// used to sort moves by immediate suitability. The top choices should be
  /// a good combination of low-risk, low-impact, and high-risk, high-impact moves
  Function computeSuitability;

  /* 
     Default compute functions
   */

  static bool defaultIsApplicable (CombatMoveType _this, Actor performer, Actor target) {
    return true;
  }
  
  static bool defaultCanContinue(CombatMoveType _this, Actor performer, Actor target) {
    return true;
  }

  static double defaultChanceToDodge (CombatMoveType _this, Actor performer, Actor target) {
    // the bigger the difference, the more/less chance
    int fightingDiff = target.modifiedDodging - performer.modifiedFighting;
    DEBUG("ChanceToDodge ${_this.string}: ${performer.name} -> ${target.name}");
    DEBUG("- $fightingDiff");

    if (fightingDiff >= 10)
        return 1.0;
    else if (fightingDiff <= -10)
        return 0.0;
    else if (fightingDiff == 0) {
      return _this.baseChanceToDodge;
    } else if (fightingDiff > 0) {
      // target is better
      return _this.baseChanceToDodge 
             + (1.0 - _this.baseChanceToDodge) * fightingDiff / 10.0;
    } else {
      // performer is better
      return _this.baseChanceToDodge 
             - (_this.baseChanceToDodge) * fightingDiff.abs() / 10.0;
    }
  }

  static double defaultChanceToBlock (CombatMoveType _this, Actor performer, Actor target) {
    // the bigger the difference, the more/less chance
    int fightingDiff = target.modifiedBlocking - performer.modifiedFighting;
    DEBUG("ChanceToBlock ${_this.string}: ${performer.name} -> ${target.name}");
    DEBUG("- $fightingDiff");

    if (fightingDiff >= 10)
        return 1.0;
    else if (fightingDiff <= -10)
        return 0.0;
    else if (fightingDiff == 0) {
      return _this.baseChanceToBlock;
    } else if (fightingDiff > 0) {
      // target is better
      return _this.baseChanceToBlock 
             + (1.0 - _this.baseChanceToBlock) * fightingDiff / 10.0;
    } else {
      // performer is better
      return _this.baseChanceToBlock 
             - (_this.baseChanceToBlock) * fightingDiff.abs() / 10.0;
    }
  }

  static int defaultComputeSuitability (CombatMoveType _this, Actor performer, Actor target) {
    if (_this.isOffensive) {
      // TODO: revisit and make it better
      int value = _this.damage + (_this.stanceDamage / 5).toInt();
      value *= ((1 - _this.chanceToDodge(performer, target)) * (1 - _this.chanceToBlock(performer, target)) * 10).toInt();
      if (performer.previousMove != null) // similar moves as the last one get minus points
        value -= countBits(_this.type & performer.previousMove.type);
      return value;
    } else {
      // TODO: defensive suitability
      return _this.fightingMod;
    }
  }

  /*
  static List<String> getLuckStrings(double chance) {
    // result [0] is intro, result [1] is an adverb, result[2] is a modifying end of sentence
    List<String> result = new List<String>(3);
    if (chance < 0.05) {
      return randomly([
          ["impossibly, ", 
          "by awesome chance, ", 
          "by pure chance, ",
          ]);
    }
    if (chance < 0.2)
      return randomly(["with luck, ", "with some luck, ","by odd chance, "]);
    if (chance > 0.8 && chance < 0.95)
      return randomly(["easily, ", "effortlessly, ", "without difficulty, "]);
    if (chance >= 0.95)
      return randomly(["without a sweat, ", "as a matter of course, "]);
  }
  */

  /* 
     Default event handler functions
   */

  static void defaultOnStart (CombatMoveType _this, CombatEvent e) {
    String again = (e.performer.previousMove == _this) ? " again" : "";
    if (!e.performer.isPlayer) {
      e.performer.report("<subject> wind<s> up to ${_this.choiceString}$again", endSentence:true, object:e.target);
    } else {
      e.performer.report("you decide to ${_this.choiceString}$again", endSentence:true, object:e.target);
    }
  }

  /*
  static void defaultOnUpdate (CombatMoveType move, CombatEvent e) {
  }

  static void defaultOnEnd (CombatMoveType move, CombatEvent e) {
  }
  */

  static void defaultOnSufferDodge (CombatMoveType _this, CombatEvent e) {
    e.target.report("<subject> dodge<s> <object's> ${_this.string} (${e.chance})", object:e.performer, positive:true);
  }

  static void defaultOnSufferMeetWeapon (CombatMoveType _this, CombatEvent e) {
    // TODO: define citoslovce ("Thump", "Cling", Clank!") - BUT in the Weapon or move
    e.target.report("<subject> meet<s> <object's> move with <subject's> ${e.target.weapon.name} (${e.chance})", object:e.performer, positive:true);
  }

  static void defaultOnSufferBlock (CombatMoveType _this, CombatEvent e) {
    e.target.report("<subject> deflect<s> it", object:e.performer, positive:true);
    int actualStanceDamage = Math.max(
        0, 
        (_this.stanceDamage / 2).toInt() - e.target.modifiedFighting
    );
    if (actualStanceDamage > 0) {
      e.target.report("the blow was hard", negative:true);
      e.target.stance -= actualStanceDamage;
    }
  }

  static void defaultOnSufferDeflect (CombatMoveType _this, CombatEvent e) {
    e.performer.report("<subject> hit<s> (${e.chanceAll})", object:e.target, positive:true);
    e.performer.report("<subject's> ${e.weapon.name} bounces off <object's> ${e.armor.name}", object:e.target, negative:true);
    e.target.stance -= _this.stanceDamage;
  }

  static void defaultOnHit (CombatMoveType _this, CombatEvent e) {
    // TODO: define citoslovce ("Thump", "Cling", Clank!") - BUT in the Weapon or move
    e.performer.report("${_this.thirdPartyString} (${e.chanceAll})", object:e.target, positive:true);
    e.target.hitpoints -= _this.damage;
    e.target.stance -= _this.stanceDamage;
  }

  static void defaultOnCancel (CombatMoveType _this, CombatEvent e) {
    e.performer.report("there's no way <subject> can ${_this.choiceString} now", object:e.target, negative:true);
  }


  void initDefaultFunctions() {
    on = new CombatCallbackHandler(this);

    isApplicable = (Actor performer, Actor target) {
      return defaultIsApplicable(this, performer, target);
    };

    canContinue = (Actor performer, Actor target) {
      return defaultCanContinue(this, performer, target);
    };

    chanceToDodge = (Actor performer, Actor target) {
      return defaultChanceToDodge(this, performer, target);
    };

    chanceToBlock = (Actor performer, Actor target) {
      return defaultChanceToBlock(this, performer, target);
    };

    computeSuitability = (Actor performer, Actor target) {
      return defaultComputeSuitability(this, performer, target);
    };

    on["start"].add(defaultOnStart);
    //on["update"].add(defaultOnUpdate);
    //on["end"].add(defaultOnEnd);
    on["hit"].add(defaultOnHit);
    on["sufferDeflect"].add(defaultOnSufferDeflect);
    on["sufferBlock"].add(defaultOnSufferBlock);
    on["sufferMeetWeapon"].add(defaultOnSufferMeetWeapon);
    on["sufferDodge"].add(defaultOnSufferDodge);
    on["cancel"].add(defaultOnCancel);
  }


  CombatMoveType([
      this.string = "UNNAMED MOVE",
      this.choiceString = "USE UNNAMED MOVE",
      this.thirdPartyString = "USES UNNAMED MOVE",
      this.type = 0x0,
      this.duration,
      this.recovery,
      this.damage = 0,
      this.stanceDamage = 0,
      this.baseChanceToBlock = 1.0,
      this.baseChanceToDodge = 1.0,
      this.fightingMod = 0
      ]) : super() {

    initDefaultFunctions();
  }


  // TODO: see http://en.wikipedia.org/wiki/Punch_(combat) for inspiration
  // http://www.eazycheezy.net/2010/04/how-to-throw-a-punch-by-guest-author-the-wolf.html
  CombatMoveType.Hand() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_TRG_BODY|MOVE_FRM_RIGHT|MOVE_LMB_HAND|MOVE_EFF_HITPOINTS|MOVE_PRI_QUICK|MOVE_DIR_OFFENSIVE;
    string = "hit to the stomach";
    choiceString = "hit <object> to the stomach";
    thirdPartyString = "<subject> hit<s> <object> to the stomach";
    duration = 4;
    recovery = 1;
    damage = 1;
    stanceDamage = 2;
    baseChanceToDodge = 0.1;
    baseChanceToBlock = 0.3;

    isApplicable = (Actor performer, Actor target) {
      if (performer.stance < 10)
        return false;
      return defaultIsApplicable(this, performer, target);
    };
  }

  CombatMoveType.Haymaker() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_TRG_HEAD|MOVE_FRM_RIGHT|MOVE_LMB_HAND|MOVE_EFF_HITPOINTS|MOVE_PRI_DAMAGE|MOVE_DIR_OFFENSIVE;
    string = "strike to the face";
    choiceString = "strike <object> with <subjectPronoun's> left hook";
    thirdPartyString = "<subject> strike<s> <object> with <subjectPronoun's> left hook";
    duration = 6;
    recovery = 1;
    damage = 2;
    stanceDamage = 8;
    baseChanceToDodge = 0.2;
    baseChanceToBlock = 0.2;
    fightingMod = -1;

    isApplicable = (Actor performer, Actor target) {
      if (performer.stance < 20)
        return false;
      if (target.stance < 10)
        return false;
      return defaultIsApplicable(this, performer, target);
    };

    on["hit"].addFirst((_this, CombatEvent e) {
      e.combat.storyline.add("Boom!", wholeSentence:true, positive:true);
    });
  }

  CombatMoveType.Kick() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_TRG_LEGS|MOVE_FRM_RIGHT|MOVE_LMB_LEG|MOVE_EFF_STANCE|MOVE_PRI_DAMAGE|MOVE_DIR_OFFENSIVE;
    string = "kick to the legs";
    choiceString = "kick <object's> legs";
    thirdPartyString = "<subject> kick<s> <object's> legs";
    duration = 6;
    recovery = 2;
    damage = 0;
    stanceDamage = 15;
    baseChanceToDodge = 0.2;
    baseChanceToBlock = 0.2;
    fightingMod = -1;

    isApplicable = (Actor performer, Actor target) {
      if (performer.stance < 30 || target.stance < 20)
        return false;
      return defaultIsApplicable(this, performer, target);
    };
  }

  CombatMoveType.Defense() : super () {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_DIR_DEFENSIVE|MOVE_LMB_HAND;
    string = "parry";
    choiceString = "parry <object's> move";
    thirdPartyString = "<subject> parr<ies> <object's> move";
    duration = 4;
    recovery = 0;
    fightingMod = +2;

    isApplicable = (Actor performer, Actor target) {
      if (target.target != performer)
        return false; // don't parry attacks that don't target you
      if (target.currentMove == null 
          || (target.currentMove.type.damage == 0 && target.currentMove.type.stanceDamage == 0))
        return false; // don't parry no attack and don't parry someone parrying you
      return defaultIsApplicable(this, performer, target);
    };

    on["start"].clear();
    on["start"].add((_this, CombatEvent e) {
      if (!e.performer.isPlayer) {
        e.performer.report("<subject> braces for <object's> blow", object:e.target);
      } else {
        e.performer.report("you decide to brace for <object's> blow", endSentence:true, object:e.target);
      }
      // wait for the blow
      e.performer.tillEndOfMove = e.target.tillEndOfMove + 1;
    });

    on["update"].add((_this, CombatEvent e) {
      e.performer.stance += 1;
    });
  }

  CombatMoveType.StandUp() : super () {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_DIR_DEFENSIVE|MOVE_LMB_LEG;
    string = "stand up";
    choiceString = "stand up";
    thirdPartyString = "<subject> stand<s> up";
    duration = 8;
    recovery = 0;
    fightingMod = -1;

    isApplicable = (Actor performer, Actor target) {
      return performer.stance < 20; // can only start standing up if not standing up already
    };

    on["update"].add((_this, CombatEvent e) {
      if (e.performer.tillEndOfMove <= (_this.duration / 2).toInt()) { // first few timesteps the actor is gathering - his stance doesn't rise yet
        e.performer.stance += 4;
      }
    });

    on["start"].clear();
    on["start"].add((_this, CombatEvent e) {
      String again = (e.performer.previousMove == _this) ? " again" : "";
      e.performer.report(randomly(["<subject> gather<s> to stand up$again", "<subject> begin<s> to stand up$again", "<subject> tr<ies> to stand up$again"]));
    });

    computeSuitability = (Actor performer, Actor target) {
      return 10; // when this move is isApplicable, it's probably a good idea to use it
    };
  }

  CombatMoveType.Withdraw() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_DIR_DEFENSIVE|MOVE_LMB_LEG;
    string = "withdraw";
    choiceString = "take a step back";
    thirdPartyString = "<subject> take<s> a step back";
    duration = 5;
    recovery = 0;
    fightingMod = +1;

    isApplicable = (Actor performer, Actor target) {
      if (!performer.alive)
        return false;
      if (performer.stance < 20)
        return false;
      return true; 
    };

    on["start"].replaceAllWith((_this, CombatEvent e) {
      e.performer.report(randomly(["<subject> withdraw<s>", "<subject> back<s> away", "<subject> give<s> ground"]));
    });

    on["end"].add((_this, CombatEvent e) {
      e.performer.stance += 10;
    });
  }
}

/**
  CurrentCombatMove stores the type of the move ([CombatMoveType]) 
  and the actors of the move. When an [:on.___:] event is called
  on CurrentCombatMove, it also runs that same event of the
  CombatMoveType.
  */
class CurrentCombatMove extends GameEntity {
  CombatMoveType type;
  Actor performer;
  Actor target;

  CombatCallbackHandler on;

  CurrentCombatMove(this.type, [this.performer, this.target]) {
    on = new CombatCallbackHandler(this);
  }
}

/**
  WeaponType stores information and events of all types of weapons.
  Only one object of a weapon type exists.
  Every Actor can have only one WeaponType. This makes it easier to manage
  Storyline reporting. Therefore, there can be WeaponTypes such as
  Barehanded, SwordAndShield, OneHandOnly, and such.
  */
class WeaponType extends GameEntity {
  int piercing;
  int hardness;
  int blockingMod;
  WeaponType weaponWhenPierced; // the weapon this fall backs to when pierced
  // moves that make sense with this weapon TODO
  Set<CombatMoveType> moves;
  // moves that only this weapon allows, e.g. "drop sword" for BrokenSword
  Set<CombatMoveType> specialMoves; 

  CombatCallbackHandler on;

  bool get barehanded() => hardness == 0;
  bool get blunt() => hardness > 0 && hardness < 3;
  bool get sharp() => hardness >= 3;

  static void defaultOnSufferPierced(WeaponType _this, CombatEvent e) {
    DEBUG("Suffer Pierced: ${_this.barehanded}");
    if (_this.barehanded) {
      if (e.weapon.blunt) {
        e.performer.report("<subject's> ${e.weapon.name} breaks <object's> ${_this.name}", object:e.target, positive:true);
        e.target.report("<subject> scream<s> in pain", negative:true);
        e.target.hitpoints = Math.max(1, e.target.hitpoints - 10);
      } else if (e.weapon.sharp) {
        e.performer.report("<subject's> ${e.weapon.name} goes right through <object's> ${_this.name}", object:e.target, positive:true);
        e.target.report("<subject> scream<s> in pain", negative:true);
        e.target.hitpoints = Math.max(1, e.target.hitpoints - 10);
      } else {
        throw new Exception("Weapon is not blunt nor sharp, but still is piercing barehands?");
      }
    } else {
      e.target.report("<subject's> ${_this.name} breaks", negative:true);
    }
  }

  WeaponType([
      String name,
      this.piercing = 0,
      this.hardness = 0,
      this.blockingMod = 0
      ]) {

    names = (name != null) ? [name] : ["weapon"];

    on = new CombatCallbackHandler(this);
    on["sufferPierced"].add(defaultOnSufferPierced);
  }

}

/**
  ArmorType holds information about the armor of the Actor. Usual 
  AromrTypes include: Clothes, Overall, LightArmor, but also ThickSkin, 
  Thorax, etc.
  */
class ArmorType extends GameEntity {
  int hardness;
  int dodgingMod;
  int coveringTargets; // on which types of move this is effective
  int coveringSides; // on which sides the armor is
  int coveringEffects; // is this effective on damage and/or stance damage?
  CombatCallbackHandler on;

  ArmorType([
      String name,
      this.hardness = 0,
      this.dodgingMod = 0,
      this.coveringTargets = CombatMoveType.MOVE_TRG_ALL,
      this.coveringSides = CombatMoveType.MOVE_FRM_ALL,
      this.coveringEffects = CombatMoveType.MOVE_EFF_ALL
      ]) {

    names = (name != null) ? [name] : ["armor"];

    on = new CombatCallbackHandler(this);
  }
}

/**
  CombatEvent holds information about each event during combat.
  It is passed to CombatCallbacks.
  */
class CombatEvent {
  Actor performer;
  Actor target;
  CombatMoveType move;
  WeaponType weapon;
  ArmorType armor;
  Combat combat;

  // chance of success of the most recent action (dodge/block/etc.)
  double _chance;
  double get chance() => _chance;
  void set chance(double value) {
    DEBUG("- chance: $value");
    _chance = value;
  }
  // chance that the event ends up like this
  double _chanceAll;
  double get chanceAll() => _chanceAll;
  void set chanceAll(double value) {
    DEBUG("- chanceAll: $value");
    _chanceAll = value;
  }
  // was luck excerted?
  bool luckUsed;

  // when this is assigned true, then following callbacks shouldn't be fired
  bool stopPropagation = false;

  CombatEvent([
      this.performer,
      this.target,
      this.move,
      this.weapon,
      this.armor,
      this.combat,
      this.chance,
      this.luckUsed
      ]);

  CombatEvent.fromMove(CurrentCombatMove currentMove) {
    performer = currentMove.performer;
    target = currentMove.target;
    move = currentMove.type;
    weapon = performer.weapon;
    assert(performer.combat == target.combat);
    combat = performer.combat;
  }
}

/**
  CombatCallback stores all callbacks assigned for a given event and given
  GameEntity. It behaves like a Queue of Functions, but there are differences:
  1) you can dispatchAll(), 2) the class keeps a pointer to the GameEntity,
  3) when the GameEntity is a CurrentCombatMove, its CombatMoveType's on.___
  event is also called.
  */
class CombatCallback {
  Queue<Function> functions;

  GameEntity _this;
  String _key;

  CombatCallback(this._this, this._key) {
    functions = new Queue<Function>();
  }

  void add(Function f) {
    functions.add(f);
  }
  void addFirst(Function f) {
    functions.addFirst(f);
  }
  void addLast(Function f) {
    functions.addLast(f);
  }
  void clear() {
    functions.clear();
  }
  void replaceAllWith(Function f) {
    clear();
    add(f);
  }

  Function get first() => functions.first();
  Function get last() => functions.last();

  void dispatchAll([CombatEvent e]) {
    // if this is called from a currentMove, 
    // then apply currentMove's performer & target
    if (_this is CurrentCombatMove) {
      if (e == null) {
        e = new CombatEvent.fromMove(_this);
      }
      // call this CurrentCombatMove's type EventHandler first
      _this.type.on[_key].dispatchAll(e);
    }
    // TODO: check if func returns 'true', if so, delete the callback afterwards (one-shot callback)
    for (Function func in functions) { // TODO: make sure we're going in order
      if (e == null)
        func(_this);
      else {
        func(_this, e);
        if (e.stopPropagation)
          break;
      }
    }
  }
}

/** 
  Every object can have an "on" member of class CombatCallbackHandler.
  Objects can then add listeners/handlers by doing 
  [: on["hit"].add((_this, performer, target) { ... }); :]

  When an event occurs, all the listeners are called using
  [: on["hit"].dispatchAll(); :]
  */
class CombatCallbackHandler {

  // reference to the caller object
  GameEntity _this;

  // on.___ callbacks are stored in a HashMap
  Map<String,CombatCallback> _callbacks;

  /// When callbacks are accessed, they are either returned
  /// or -- in case they don't exist yet -- first created and 
  /// then returned.
  CombatCallback operator [](String key) {
    if (_callbacks.containsKey(key))
      return _callbacks[key];
    else {
      _callbacks[key] = new CombatCallback(_this, key);
      return _callbacks[key];
    }
  }

  void operator []=(String key, CombatCallback value) {
    _callbacks[key] = value;
  }

  CombatCallbackHandler(this._this) {
    _callbacks = new Map<String,CombatCallback>();
  }
}


/// Events that can be started with start(event) and TIS takes care of the repetition.

interface LoopedEvent {
  bool finished;
  bool interactionNeeded;
  void start();
  void update();
  void updateUntilInteraction();
  List<Choice> playerChoices;
  Storyline storyline;
}


class Combat extends GameEntity implements LoopedEvent {
  Storyline storyline;

  static final int MAX_MOVES_PRESENTED = 5;

  bool _started = false;
  bool finished = false;
  bool interactionNeeded = false;

  CombatCallbackHandler on;

  int _prevTime = 0;
  int time = 0;

  void start() {
    actors.forEach((a) { 
        a.combat = this; 
        if (a.isPlayer)
          _player = a;
    });
    _started = true;
  }

  List<Actor> actors;
  Actor _player;
  List<Choice> playerChoices;

  Combat() : super() {
    storyline = new Storyline();
    actors = new List();
    playerChoices = new List();
    on = new CombatCallbackHandler(this);
  }

  /// The main function that gets called every single move and calls each actor to do their own stuff.
  void update() {
    // find out if time passed since last time update() was called
    bool timePassed = (time > _prevTime);
    _prevTime = time;

    if (timePassed) {
      this.on["update"].dispatchAll();

      actors.forEach((actor) {
        actor.update();
        actor.on["update"].dispatchAll();
      });

      // make sure the fight still needs to continue
      if (!actors.some((a) => a.alive && actors.some((b) => b.alive && b.team != a.team))) {
        finished = true;
        return;
      }
    }

    if (_player != null && _player.alive && _player.tillEndOfMove <= 0) {
      if (_player.target == null) {
        // let player choose his target
        List<Actor> possibleEnemies = actors.filter((o) => o.team != _player.team && o.alive);
        if (possibleEnemies.length == 1) {
          _player.target = possibleEnemies[0];
        } else {
          possibleEnemies.forEach((enemy) {
              playerChoices.add(new Choice("Target ${enemy.name}.", showNow:true, then:() { storyline.add("<subject> now lock on to <object>", subject:_player, object:enemy); _player.target = enemy; }));
          });
        }
      } else {
        // find out possible moves the player can perform on the target
        List<CombatMoveType> possibleMoves = _player.getPossibleMoves(max:MAX_MOVES_PRESENTED);
        if (!possibleMoves.isEmpty()) {
          possibleMoves.sort((a,b) => a.type - b.type);
          possibleMoves.forEach((move) {
              playerChoices.add(new Choice(capitalize(Storyline.getString(move.choiceString, subject:_player, object:_player.target)), showNow:true, then:() { _player.currentMove = move; }));
          });
        }
        // let player target someone else
        if (actors.some((a) => a.alive && a != _player.target && a.team != _player.team))
          playerChoices.add(new Choice("Target another enemy.", showNow:true, then:() { _player.target = null; time--; })); 
      }

      if (!playerChoices.isEmpty()) {
        interactionNeeded = true;
      }
    }

    time++;
  }

  void updateUntilInteraction() {
    while (!finished && !interactionNeeded) {
      update();
    }
    interactionNeeded = false;  // reset for next run
  }
}

</classes>

<library>

void start(LoopedEvent event) {
  vars["_curLoopedEvent"] = event;
  vars["_curLoopedEventChoices"] = new List<Choice>();
  event.playerChoices = vars["_curLoopedEventChoices"];
  event.start();
  updateLoopedEvent();
}

void updateLoopedEvent() {
  LoopedEvent event = vars["_curLoopedEvent"];
  if (event.finished)
    return;
  event.playerChoices.clear();
  event.updateUntilInteraction();
  echo(event.storyline.toString());
  event.storyline.clear();
  choices.addAll(event.playerChoices);
  nextScript(updateLoopedEvent);
}

</library>
