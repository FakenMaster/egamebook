<init>
  v_weaponHands = new WeaponType({
      "piercing": 0,
      "hardness": 0
  });

  v_weaponHands.on["block"].add((_this, performer, target) {
      target.report("<subject> meet<s> <object's> move with <subject's> hands", object:performer, positive:true);
  });

  v_moveFootSweep = new CombatMoveType({
      "type": CombatMoveType.MOVE_TRG_LEGS|CombatMoveType.MOVE_FRM_RIGHT|CombatMoveType.MOVE_LMB_LEG|CombatMoveType.MOVE_EFF_STANCE|CombatMoveType.MOVE_PRI_DAMAGE|CombatMoveType.MOVE_DIR_OFFENSIVE,
      "string": "foot sweep",
      "choiceString": "sweep <object's> feet",
      "thirdPartyString": "<subject> undercut<s> <object's> legs",
      "duration": 6,
      "recovery": 4,
      "stanceDamage": 25,
      "baseChanceToDodge": 0.2,
      "baseChanceToBlock": 0.1,
      "fightingMod": -1
  });

  v_moveFootSweep.on["hit"].add((_this, performer, target) {
      target.currentMove = null;
  });

  v_moveStomach = new CombatMoveType.Hand();
  v_moveLeftHook = new CombatMoveType.Haymaker();
  v_moveDefense = new CombatMoveType.Defense();
  v_moveStandUp = new CombatMoveType.StandUp();
  v_moveWithdraw = new CombatMoveType.Withdraw();

  v_humanMoves = [
      v_moveStomach,
      v_moveDefense,
      v_moveLeftHook,
      v_moveWithdraw,
      v_moveStandUp,
      v_moveFootSweep
  ];

  v_player = new Player();
  v_player.moves.addAll(v_humanMoves);
  v_player.weapon = v_weaponHands;
  v_player.fighting = 1;
</init>


--- 
welcome

# Thin Ice System (TIS) Unit Testing



- Play [interactiveTest]
- Run tests [autoTest]

---
interactiveTest

You encounter a worthy opponent: a homeless man!

<dart>
  v_man = new Actor();
  v_man.moves.addAll(v_humanMoves);
  v_man.weapon = v_weaponHands;
  v_man.fighting = 0;
  v_man.names = ["the hobo", "the homeless man", "the man"];
  v_man.on["sufferHit"].add((_this, performer, target) { _this.report("<subject> looks very surprised"); });
</dart>

He charges at you!

<dart>
  v_combat = new Combat();
  v_combat.actors.addAll([ v_player, v_man ]);

  start(v_combat);
</dart>

And that''s the end of the fight!


---
autoTest

Asserting that more actors of the same type can take out less actors, most of the time.

<dart>
  v_NUMBER_OF_RUNS = 10;
  v_teamOneWins = 0;
  v_teamTwoWins = 0;

  Function runTest = () {
    v_swarmer1 = new Actor();
    v_swarmer1.names = ["the first swarmer"];
    v_swarmer1.pronoun = Storyline.IT;
    v_swarmer1.moves.addAll(v_humanMoves);
    v_swarmer1.team = 2;

    v_swarmer2 = new Actor();
    v_swarmer2.names = ["the second swarmer"];
    v_swarmer2.pronoun = Storyline.IT;
    v_swarmer2.moves.addAll(v_humanMoves);
    v_swarmer2.team = 2;

    v_swarmer3 = new Actor();
    v_swarmer3.names = ["the third swarmer"];
    v_swarmer3.pronoun = Storyline.IT;
    v_swarmer3.moves.addAll(v_humanMoves);
    v_swarmer3.team = 2;

    v_individual1 = new Actor();
    v_individual1.names = ["the first individual"];
    v_individual1.moves.addAll(v_humanMoves);
    v_individual1.team = 3;

    v_individual2 = new Actor();
    v_individual2.names = ["the second individual"];
    v_individual2.moves.addAll(v_humanMoves);
    v_individual2.team = 3;

    v_combat = new Combat();
    v_combat.actors.addAll([v_individual1, v_swarmer1, v_individual2, v_swarmer2, v_swarmer3]);
    v_combat.on["update"].add((combat) {
      if ((combat.time % 10) == 0)
        combat.storyline.add("it's 10 seconds later");
    });
    v_combat.start();
    v_combat.updateUntilInteraction();

    assert(v_combat.finished);
    assert((!v_swarmer1.alive && !v_swarmer2.alive && !v_swarmer3.alive) 
          || (!v_individual1.alive && !v_individual2.alive));

    DEBUG(v_combat.storyline.toString());

    if (v_individual1.alive || v_individual2.alive)
      v_teamTwoWins++;
    else
      v_teamOneWins++;
  };

  for (int i = 0; i < v_NUMBER_OF_RUNS; i++)
    runTest();
  DEBUG("Swarm vs Individual: ${vars['teamOneWins']} : ${vars['teamTwoWins']}");
  assert(v_teamOneWins > v_teamTwoWins);

</dart>

---
playable

<dart>
  v_wolf = new Actor();
  v_wolf.names = ["the orcling", "the orcling", "the young orcling"];
  v_wolf.pronoun = Storyline.IT;
  v_wolf.moves.addAll(v_humanMoves);
  v_wolf.hitpoints = 2;
  v_wolf.speed = 1;

  v_orc = new Actor();
  v_orc.names = ["the orc", "the big orc", "the ugly orc"];
  v_orc.moves.addAll(v_humanMoves);
  v_combat = new Combat();
  v_combat.actors.addAll([v_wolf, v_orc,v_player]);
  v_combat.on["update"].add((combat) {
    if ((combat.time % 10) == 5)
      combat.storyline.add("a lonely bird beeps in the distance");
  });
  start(v_combat);
</dart>

<dart>
  if (!v_player.alive)
    goto(1);
</dart>

Congratulations! You beat your first enemies!


---
die

You died like the bitch you are.



<classes>

void DEBUG(String str) {
  print(str);
}

Dynamic randomly(List choices) {
  num number = choices.length;
  if (number == 0)
    throw new Exception("Cannot randomly choose from an empty set.");
  double portionSize = 1.0 / number;
  double rand = Math.random();
  int which = (rand / portionSize).floor().toInt();

  return choices[which];
}

// from http://en.wikipedia.org/wiki/Hamming_weight
int countBits(int x) {
  int count;
  for (count=0; x > 0; count++)
      x &= x - 1;
  return count;
}

String capitalize(String str) {
  String firstLetter = str[0].toUpperCase();
  if (str.length == 1)
    return firstLetter;
  else 
    return "$firstLetter${str.substring(1)}";
}

class Pronoun {
  // see http://en.wikipedia.org/wiki/Latin_declension
  final String nominative; // He (kdo? co?)
  // vocative // not used
  final String accusative; // Him (koho? co?)
  final String genitive;   // His (koho? ceho?)
  // dative // not used
  // ablative
  // locative

  String toString() => nominative;

  const Pronoun(this.nominative, this.accusative, this.genitive); 
}

class Storyline {
  StringBuffer strBuf;
  List<Map<String,Dynamic>> reports;

  static final String SUBJECT = "<subject>";
  static final String SUBJECT_POSSESIVE = "<subject's>";
  static final String OBJECT = "<object>";
  static final String OBJECT_POSSESIVE = "<object's>";
  static final String SUBJECT_PRONOUN = "<subjectPronoun>";
  static final String SUBJECT_PRONOUN_POSSESIVE = "<subjectPronoun's>";
  static final String OBJECT_PRONOUN = "<objectPronoun>";
  static final String OBJECT_PRONOUN_POSSESIVE = "<objectPronoun's>";
  static final String ACTION = "<action>";
  static final String VERB_S = "<s>";
  static final String VERB_ES = "<es>"; // e.g. in "goes"
  static final String VERB_IES = "<ies>"; // e.g. in "tries", "flies"
  static final String VERB_DO = "<does>";
  static final String VERB_BE = "<is>";

  static final Pronoun YOU = const Pronoun("you", "you", "your");
  static final Pronoun HE = const Pronoun("he", "him", "his");
  static final Pronoun SHE = const Pronoun("she", "her", "her");
  static final Pronoun IT = const Pronoun("it", "it", "its");

  Storyline add(String str, [Actor subject, Actor object, bool but=false, bool positive=false, bool negative=false, bool endSentence=false, bool startSentence=false, bool wholeSentence=false]) {
    reports.add( {
        "string": str,
        "subject": subject,
        "object": object,
        "but": but,
        "positive": positive,
        "negative": negative,
        "endSentence": endSentence,
        "startSentence": startSentence,
        "wholeSentence": wholeSentence
    });
  }

  String string(int i) {
    if (i < 0 || i >= reports.length)
      return null;
    else
      return reports[i]["string"];
  }
  Actor subject(int i) {
    if (i < 0 || i >= reports.length)
      return null;
    else
      return reports[i]["subject"];
  }
  Actor object(int i) {
    if (i < 0 || i >= reports.length)
      return null;
    else
      return reports[i]["object"];
  }

  /// taking care of all the exceptions and rules when comparing different reports
  /// call: [: same('subject', i, i+1) ... :]
  bool same(String key, int i, int j) {
    if (!valid(i) || !valid(j))
      return false;
    if (reports[i][key] == null || reports[j][key] == null)
      return false;
    if (reports[i][key] == reports[j][key])
      return true;
    else
      return false;
  }

  bool valid(int i) {
    if (i >= reports.length || i < 0)
      return false;
    else
      return true;
  }

  bool sameSentiment(int i, int j) {
    if (!valid(i) || !valid(j))
      return false;
    if (!same('subject', i, j))
      return false;
    if (reports[i]["positive"] && reports[j]["positive"])
      return true;
    if (reports[i]["negative"] && reports[j]["negative"])
      return true;
    else
      return false;
  }

  bool oppositeSentiment(int i, int j) {
    if (!valid(i) || !valid(j))
      return false;
    if (!same('subject', i, j))
      return false;
    if (reports[i]["positive"] && reports[j]["negative"])
      return true;
    if (reports[i]["negative"] && reports[j]["positive"])
      return true;
    else
      return false;
  }

  /// makes sure the sentence flows well with the previous sentence(s), then calls getString to do the rest
  String substitute(int i, String str, [bool useSubjectPronoun=false, bool useObjectPronoun=false]) {
    String result = str.replaceAll(ACTION, string(i));
    if (useObjectPronoun || same('object', i, i-1)) {// if doing something to someone in succession, use pronoun
      result = result.replaceAll(OBJECT, object(i).pronoun.accusative);
      result = result.replaceAll(OBJECT_POSSESIVE, object(i).pronoun.genitive);
    }
    if (useSubjectPronoun || same('subject', i, i-1)) {
      result = result.replaceAll(SUBJECT, subject(i).pronoun.nominative);
      result = result.replaceAll(SUBJECT_POSSESIVE, subject(i).pronoun.genitive);
    }
    // if someone who was object last sentence is now subject (and it's not misleading), use pronoun
    if (object(i-1) != null && subject(i) != null && subject(i-1) != null
        && object(i-1) == subject(i) && subject(i-1).pronoun != subject(i).pronoun) {
      result = result.replaceAll(SUBJECT, subject(i).pronoun.nominative);
      result = result.replaceAll(SUBJECT_POSSESIVE, subject(i).pronoun.genitive);
    }
    // same as previous, but with object-subject reversed
    if (subject(i-1) != null && object(i) != null && subject(i-1) != null
        && subject(i-1) == object(i) && subject(i-1).pronoun != subject(i).pronoun) {
      result = result.replaceAll(OBJECT, object(i).pronoun.accusative);
      result = result.replaceAll(OBJECT_POSSESIVE, object(i).pronoun.genitive);
    }
    return getString(result, subject(i), object(i));
  }

  /// Takes care of substitution of stopwords
  static String getString(String str, [Actor subject, Actor object]) {
    String result = str;
    if (subject != null) {
      if (subject.isPlayer) { // don't talk like a robot: "player attack wolf", TODO: Storyline.YOU instead?
        result = result.replaceAll(SUBJECT, subject.pronoun.nominative);
        result = result.replaceAll(SUBJECT_POSSESIVE, subject.pronoun.genitive);
        result = result.replaceAll(VERB_S, "");
        result = result.replaceAll(VERB_ES, "");
        result = result.replaceAll(VERB_IES, "y");
        result = result.replaceAll(VERB_DO, "do");
        result = result.replaceAll(VERB_BE, "are");
      }
      else { // third person
        result = result.replaceAll(SUBJECT, subject.name);
        result = result.replaceAll(VERB_S, "s");
        result = result.replaceAll(VERB_ES, "es");
        result = result.replaceAll(VERB_IES, "ies");
        result = result.replaceAll(VERB_DO, "does");
        result = result.replaceAll(VERB_BE, "is");
      }
      result = result.replaceAll(SUBJECT_PRONOUN, subject.pronoun.nominative);
      result = result.replaceAll(SUBJECT_POSSESIVE, "${subject.name}'s");
      result = result.replaceAll(SUBJECT_PRONOUN_POSSESIVE, subject.pronoun.genitive);
    }
    if (object != null) {
      if (object.isPlayer) { // don't talk like a robot: "wolf attacks player"
        result = result.replaceAll(OBJECT, object.pronoun.accusative);
        result = result.replaceAll(OBJECT_POSSESIVE, object.pronoun.genitive);
      } else
        result = result.replaceAll(OBJECT, object.name);
      result = result.replaceAll(OBJECT_PRONOUN, object.pronoun.accusative);
      result = result.replaceAll(OBJECT_POSSESIVE, "${object.name}'s");
      result = result.replaceAll(OBJECT_PRONOUN_POSSESIVE, object.pronoun.genitive);
    }

    return result;
  }

  Storyline() {
    reports = new List<Map<String,Dynamic>>();
    strBuf = new StringBuffer();
  }

  void clear() {
    reports.clear();
    strBuf.clear();
  }

  /// The main function that strings reports together into a coherent story.
  String toString() {
    final int length = reports.length;
    if (length < 1)
      return "";
    final int MAX_SENTENCE_LENGTH = 3;
    int lastEndSentence = -1;
    bool endSentence = true; // previous sentence was ended
    bool endSentenceNeeded = false; // this sentence needs to be ended
    bool but = false; // this next sentence needs to start with but
    for (int i=0; i < length; i++) {
      // TODO: look into future - make sentences like "Although __, __"
      if (i != 0) {
        // solve flow with previous sentence
        bool objectSubjectSwitch = 
                 reports[i-1]["subject"] == reports[i]["object"]
              && reports[i-1]["object"] == reports[i]["subject"];
        but = reports[i]["but"] || oppositeSentiment(i, i-1);
        endSentence = 
          (i - lastEndSentence >= MAX_SENTENCE_LENGTH) 
          || endSentenceNeeded
          || reports[i]["startSentence"] 
          || reports[i-1]["endSentence"] 
          || reports[i]["wholeSentence"]
          || !(same('subject', i, i-1) || objectSubjectSwitch)
          || (but && (i - lastEndSentence > 1));
        endSentenceNeeded = false;

        // DEBUG("SENT: ${string(i)}\n- whole=${reports[i]["endSentence"]}
        if (endSentence) {
          if (reports[i-1]["wholeSentence"]) // don't write period after "Boom!"
            strBuf.add(" ");
          else
            strBuf.add(". ");
          if (but && !reports[i]["wholeSentence"])
            strBuf.add(randomly(["But ", "But ", "However, ", "Nonetheless, ", "Nevertheless, "]));
        } else { // let's try and glue [i-1] and [i] into one sentence
          if (but) {
            strBuf.add(randomly([" but ", " but ", " yet ", ", but "]));
            if (!sameSentiment(i, i+1))
              endSentenceNeeded = true;
          } else {
            if (same('subject', i, i-1) && string(i).startsWith("$SUBJECT ")
                && i < length - 1  && i - lastEndSentence < MAX_SENTENCE_LENGTH - 1) {
              strBuf.add(", ");
            } else {
              strBuf.add(randomly([" and ", " and ", ", and "]));
              endSentenceNeeded = true;
            }
          }
        }
      }

      String report = string(i);
      // clear subjects when e.g. "Wolf hits you, it growls, it strikes again."
      if (!endSentence)
        if (same('subject', i, i-1))
          if (string(i-1).startsWith("$SUBJECT "))
            if (report.startsWith("$SUBJECT "))
              report = report.replaceFirst("$SUBJECT ", "");

      report = substitute(i, report);

      if ((endSentence || i == 0) && !but)
        report = capitalize(report);

      // add the actual report
      strBuf.add(report);

      // set variables for next iteration
      if (endSentence)
        lastEndSentence = i;
      if (reports[i]["wholeSentence"])
        endSentenceNeeded = true;
    }

    // add last dot
    if (!reports[length-1]["wholeSentence"])
      strBuf.add(".");

    return strBuf.toString();
  }
}

class GameEntity {
  List <String> names;
  Pronoun pronoun = Storyline.IT;

  GameEntity() {
    names = new List();
  }

  String get name() => randomly(names);
}

class Actor extends GameEntity {
  // current state
  bool alive = true;
  bool isPlayer = false;
  int team = 2; // actors are on team 2 (Enemy) by default
  int _hitpoints;
  // from 0 = lying on the ground to 50 = professional combat stance
  // 0=lying, 10=on_four, 20=almost_falling, 30=shaken, 40=firm_stance, 50=pro_stance
  int _stance;  
  List<String> stanceUpStrings;
  List<String> stanceDownStrings;
  List<CombatMoveType> moves;
  CurrentCombatMove _currentMove;
  CombatMoveType previousMove; // keeps track of previous move's type so that actors don't do the same thing over and over again
  WeaponType weapon;
  ArmorType armor;

  int tillEndOfMove = 0;
  bool recoveringFromMove = false;

  Combat combat;
  Actor _target;

  CombatEventHandler on;

  // an utility function that prints to the combat's storyline, pre-filling this actor as the subject
  void report(String str, [Actor subject, Actor object, bool but=false, bool positive=false, bool negative=false, bool endSentence=false, bool startSentence=false, bool wholeSentence=false]) {
    if (combat == null)
      return;
    if (subject == null)
      subject = this;
    combat.storyline.add(str, subject:subject, object:object, but:but, positive:positive, negative:negative, endSentence:endSentence, startSentence:startSentence, wholeSentence:wholeSentence);
  }

  /// returns the fighting ability modified by current move and stance
  int get modifiedFighting() {
    int stanceMod = Math.max((((29 - _stance) / 10) + 1), 0).toInt(); // stance 0-9 => -3, stance 10-19 => -2, 20-29 => -1. Stance 30+ => no mod
    int hitpointsMod = Math.max(0, (((maxHitpoints - _hitpoints)/maxHitpoints - 0.7) * 10)).toInt(); // if hitpoint are below 20% of maxHitpoint => -1, below 10% => -2
    if (currentMove == null)
      return fighting - stanceMod - hitpointsMod;
    else
      return fighting - stanceMod - hitpointsMod + currentMove.type.fightingMod;
  }

  CurrentCombatMove get currentMove() => _currentMove;
  void set currentMove(CombatMoveType value) {
    if (_currentMove != null)
      previousMove = _currentMove.type;
    if (value == null) {
      if (_currentMove != null) {
        tillEndOfMove = _currentMove.type.recovery; // do not substract speed from recovery - this makes speed too powerful
        if (tillEndOfMove > 0)
          recoveringFromMove = true;
      }

      _currentMove = null;
    } else {
      _currentMove = new CurrentCombatMove(value, this, target);
      tillEndOfMove = _currentMove.type.duration - (Math.random() * 2).round().toInt(); // speed gives a chance to substract from a move's duration
    }
  }

  int get hitpoints() => _hitpoints;
  void set hitpoints(int value) {
    if (value <= 0) {
      alive = false;
      on["die"].dispatchAll();
      report("<subject> ${randomly(['pass<es> out','lose<s> consciousness','black<s> out','go<es> down'])}", negative:true);
      return;
    }
    if (value < _hitpoints && value == 1)
      report("<subject> looks like hell", negative:true);
    else if (_hitpoints > 3 && (value == 2 || value == 3)) {
      on["update"].add((Actor a) {
          if (a.combat.time % 12 == 6)
            if (randomly([true, false]))
              a.report("blood is dripping into <subject's> eyes", negative:true);
      });
      report("<subject> <is> badly hurt", negative:true);
    }
    if (value < _hitpoints) {
      on["hitpointsDown"].dispatchAll();
      if (currentMove != null)
        currentMove.on["hitpointsDown"].dispatchAll();
    } else if (value > _hitpoints) {
      on["hitpointsUp"].dispatchAll();
      if (currentMove != null)
        currentMove.on["hitpointsUp"].dispatchAll();
    }
    _hitpoints = Math.min(value, maxHitpoints);
  }

  int get stance() => _stance;
  void set stance(int value) {
    if (!alive)
      return;
    int prevStance = _stance;
    _stance = Math.min(value, maxStance);
    _stance = Math.max(0, _stance);
    // only report when stance is changed between levels
    if ((_stance / 10).toInt() != (prevStance / 10).toInt()) {
      if (_stance > prevStance) {
        report(stanceUpStrings[Math.min(5, (_stance / 10).toInt())], positive:true);
        on["stanceUp"].dispatchAll();
        if (currentMove != null)
          currentMove.on["stanceUp"].dispatchAll();
      } else {
        report(stanceDownStrings[Math.min(5, (_stance / 10).toInt())], negative:true);
        on["stanceDown"].dispatchAll();
        if (currentMove != null)
          currentMove.on["stanceDown"].dispatchAll();
        if (prevStance - _stance > 10 && _stance < 10) // damage from fall
          hitpoints -= 1;
      }
    }
  }

  Actor get target() => _target;
  void set target(Actor value) {
    _target = value;
    previousMove = null;
  }

  Actor() : super() {
    on = new CombatEventHandler(this);
    weapon = new WeaponType();
    armor = new ArmorType();

    // init with defaults
    names = ["actor"];
    pronoun = Storyline.HE;
    _hitpoints = maxHitpoints;
    _stance = maxStance;

    moves = new List();
    stanceUpStrings = const [
        "",  // no need for this string - nowhere to stand up from
        "<subject> get<s> to <subjectPronoun's> knees",
        "<subject> stand<s> up",
        "<subject> regain<s> some balance",
        "<subject's> stance gets firm",
        "<subject> go<es> into a perfect combat stance" 
    ];
    stanceDownStrings = const [
        "<subject> fall<s> to the ground",
        "<subject> fall<s> to <subjectPronoun's> knees",
        "<subject> <is> almost ready to fall",
        "<subject> get<s> off balance",
        "<subject> lose<s> <subjectPronoun's> professional stance",
        "" // no need for this string (yet?) - nowhere to fall from
    ];
  }

  void update() {
    if (!alive)
      return;

    on["update"].dispatchAll();

    if (!alive) // make sure actor doesn't move after being poisoned to death, for example
      return;

    tillEndOfMove--; // just let the time pass

    if (tillEndOfMove > 0) {
      if (target != null && !target.alive 
          && currentMove != null && currentMove.type.offensive) { // stop attack if actor already dead 
        currentMove.on["cancel"].dispatchAll(this, target);
        currentMove = null;
        target = null;
      } else if (currentMove != null && currentMove.type.update != null) {
        if (currentMove.type.canContinue(this, target))
          currentMove.on["update"].dispatchAll(this, target);
        else { // cancel move if it's no longer applicable
          currentMove.on["cancel"].dispatchAll(this, target);
          currentMove = null;
        }
      }
    } else {
      // effect of finished move
      if (currentMove != null) {
        if (currentMove.type.canContinue(this, target)) {
          if (currentMove.type.isOfType(CombatMoveType.MOVE_DIR_OFFENSIVE)) {
            // resolve if target dodged the attack. Difference between fighting skills
            // means extra tries (throws) for the party that has the higher number
            double chance = currentMove.type.chanceToDodge(this, target);
            int throws = 1 + (this.fighting - target.modifiedFighting).abs();
            bool targetDodged;
            while (throws > 0) {
              targetDodged = Math.random() < chance;
              if (targetDodged && (target.modifiedFighting >= this.fighting))
                break;  // if target is more skillfull than attacker and he dodged once, this is it
              if (!targetDodged && (this.fighting >= target.modifiedFighting))
                break;  // similar here
              throws--;
            }
            if (targetDodged) {
              // DODGE
              target.on["dodge"].dispatchAll(this, target); // dodging is mailny actor's thing
              currentMove.type.applyDodge(this, target);
              currentMove.on["sufferDodge"].dispatchAll(this, target);
              this.on["sufferDodge"].dispatchAll(this, target);
            } else {
              // same as above, but for blocks
              chance = currentMove.type.chanceToBlock(this, target);
              throws = 1 + (this.fighting - target.modifiedFighting).abs();
              bool targetBlocked;
              while (throws > 0) {
                targetBlocked = Math.random() < chance;
                if (targetBlocked && (target.modifiedFighting >= this.fighting))
                  break;
                if (!targetBlocked && (this.fighting >= target.modifiedFighting))
                  break;
                throws--;
              }
              if (targetBlocked) {
                // BLOCK
                target.on["block"].dispatchAll(this, target);
                target.weapon.on["block"].dispatchAll(this, target); // blockin is mailny weapon's thing
                currentMove.type.applyBlock(this, target);
                currentMove.on["sufferBlock"].dispatchAll(this, target);
                this.on["sufferBlock"].dispatchAll(this, target);
              } else {
                // HIT
                currentMove.type.applyHit(this, target);
                currentMove.on["hit"].dispatchAll(this, target);
                target.armor.on["sufferHit"].dispatchAll(this, target); // being hit is mainly armor's thing
                target.on["sufferHit"].dispatchAll(this, target);
                if (target.currentMove != null)
                  target.currentMove.on["sufferHit"].dispatchAll(this, target);
                this.on["hit"].dispatchAll(this, target);
              }
            }
          } else { // non-offensive move ended
            currentMove.type.applyEnd(this, target);
            currentMove.on["end"].dispatchAll();
          }
        } else {
          // cannot continue
          currentMove.on["cancel"].dispatchAll();
          currentMove = null;
          return;
        }
      }
      // AI
      if (!isPlayer) {
        if (target == null || !target.alive) {
          List<Actor> possibleEnemies = combat.actors.filter((o) => o.team != team && o.alive);
          if (!possibleEnemies.isEmpty())
            target = randomly(possibleEnemies);
          else {
            alive = false; // TODO: more elegant way to make sure combats don't wage forever
            return;
          }
        }

        if (target == null || !moves.some((m) => m.applicable(this,target)) ) {
          // no target or no combat moves applicable to the target, TODO: try to change target?
          report('<subject> ${randomly(["just stands there", "doesn\'t do anything", "does nothing"])}');
        } else {
          currentMove = chooseMove();
          currentMove.type.start(this, target);
          currentMove.on["start"].dispatchAll();
        }
      }
    }
  }

  // List moves
  List<CombatMoveType> getPossibleMoves([int max=1000]) {
    List<CombatMoveType> possibleMoves = moves.filter((m) => m.applicable(this,target));
    if (possibleMoves.length < 2)
      return possibleMoves;

    // first, sort by suitability (computeSuitability contains logic against repeating last move)
    possibleMoves.sort((a,b) => b.computeSuitability(this,target) - a.computeSuitability(this,target));
    // next, bring down moves that are already mostly covered by moves above them
    // bring down moves that have large countBits(type & previous.type) / countBits(type) (100% => same type of move)
    final double MAX_SIMILARITY = 0.70;
    Map<int,CombatMoveType> redundantMovesMap = new Map<int,CombatMoveType>();
    for (int i=1; i < possibleMoves.length; i++) {
      for (int j=0; j < i; j++) {
        double similarity = countBits(possibleMoves[i].type & possibleMoves[j].type) / countBits(possibleMoves[i].type);
        if (similarity > MAX_SIMILARITY) {
          redundantMovesMap[i] = possibleMoves[i];
          break;
        }
      }
    }
    // move redundant moves at the end of the list
    List<CombatMoveType> finalMoves = new List<CombatMoveType>(possibleMoves.length);
    int regularIndex = 0; int redundantIndex = possibleMoves.length - redundantMovesMap.length;
    for (int i = 0; i < possibleMoves.length; i++) {
      if (!redundantMovesMap.containsKey(i)) {
        finalMoves[regularIndex] = possibleMoves[i];
        regularIndex++;
      } else {
        finalMoves[redundantIndex] = possibleMoves[i];
        redundantIndex++;
      }
    }

    return finalMoves.getRange(0, Math.min(finalMoves.length, max)); // return up to max moves
  }

  // AI chooses a move
  CombatMoveType chooseMove([int max=1000]) {
    List<CombatMoveType> possibleMoves = getPossibleMoves(max:max);

    // logic that gives more chance to higher (more suitable) moves
    double random = Math.random();
    int pos;
    int len = possibleMoves.length; 
    int allParts = (len*(len+1)/2).toInt(); // 1+2+3+4+.. = allParts
    double part = 0.0;

    for (pos = 0; pos < len; pos++) {
      part += len - pos;
      if (random < part / allParts)
        break;
    }

    return possibleMoves[pos];
  }

  // stats
  int maxHitpoints = 10;
  int maxStance = 45; // the best stance this actor can muster
  int speed = 0; // 0 = normal person, -x = everything takes x seconds longer, +x = dtto shorter
  int fighting = 0; // 1 = normal person, +x = number of extra block/dodge throws per turn
}

class Player extends Actor {
  Player() : super() {
    isPlayer = true;
    team = 1; // player is on team Player (1)
    names = ["player"];
    pronoun = Storyline.YOU;
  }
}

class CombatMoveType extends GameEntity {
  /// the basic description of the move
  String string;
  /// the string to be presented as a choice to the player
  /// e.g.: "hit <object> to the stomach"
  String choiceString;
  /// e.g.: "hits <object> in the stomach"
  String thirdPartyString;

  int duration; // number of turns from start to effect (=hit)
  int recovery; // number of turns it gets to start a new move again
  int damage = 0;
  int stanceDamage = 0;
  double baseChanceToDodge = 1.0;
  double baseChanceToBlock = 1.0;

  // modifiers to move's performer. Many moves will make it temporarily harder to block and dodge
  // defense moves will make it easier (positive number)
  int fightingMod = 0;

  int type = 0x0;

  static final int MOVE_TRG_HEAD = 1<<1;
  static final int MOVE_TRG_BODY = 1<<2;
  static final int MOVE_TRG_WAIST = 1<<3;
  static final int MOVE_TRG_LEGS = 1<<4;
  static final int MOVE_FRM_FRONT = 1<<5;
  static final int MOVE_FRM_LEFT = 1<<6;
  static final int MOVE_FRM_RIGHT = 1<<7;
  static final int MOVE_LMB_HAND = 1<<8;
  static final int MOVE_LMB_LEG = 1<<9;
  static final int MOVE_LMB_HEAD = 1<<10;
  static final int MOVE_EFF_HITPOINTS = 1<<11;
  static final int MOVE_EFF_STANCE = 1<<12;
  static final int MOVE_PRI_QUICK = 1<<13;
  static final int MOVE_PRI_DAMAGE = 1<<14;
  static final int MOVE_DIR_OFFENSIVE = 1<<15;
  static final int MOVE_DIR_DEFENSIVE = 1<<16;

  // utility function. Returns true if this CombatMoveType is (at least partially) of type otherType.
  bool isOfType(int otherType) => (type & otherType) != 0;

  bool get offensive() => isOfType(MOVE_DIR_OFFENSIVE);

  /// The events handler
  CombatEventHandler on;

  /// returns bool, whether this move is applicable given the two actors
  Function applicable;

  /// returns bool, whether this move can continue given the state
  Function canContinue;

  /// reports on start of the move
  Function start;

  /// gets called every turn
  Function update;

  /// end of non-offensive move
  Function applyEnd;

  /// applies and report on success
  Function applyHit;

  /// applies and report on block
  Function applyBlock;

  /// applies and report on dodge
  Function applyDodge;
 
  /// applies and reports on a cancelled move
  Function applyCancel;
 
  /// returns chance (0.0-1.0) of dodging this move
  Function chanceToDodge;

  /// returns chance (0.0-1.0) of blocking this move
  Function chanceToBlock;

  /// used to sort moves by immediate suitability. The top choices should be
  /// a good combination of low-risk, low-impact, and high-risk, high-impact moves
  Function computeSuitability;



  // Default functions

  static bool defaultApplicable (CombatMoveType move, Actor performer, Actor target) {
    return target.alive; // only perform moves when target is alive (by default)
  }
  
  static bool defaultCanContinue(CombatMoveType move, Actor performer, Actor target) {
    return target.alive;
  }

  static void defaultStart (CombatMoveType move, Actor performer, Actor target) {
    String again = (performer.previousMove == move) ? " again" : "";
    if (!performer.isPlayer) {
      performer.report("<subject> wind<s> up to ${move.choiceString}$again", endSentence:true, object:target);
    } else {
      performer.report("you decide to ${move.choiceString}$again", endSentence:true, object:target);
    }
  }

  static void defaultUpdate (CombatMoveType move, Actor performer, Actor target) {
  }

  static void defaultApplyEnd (CombatMoveType move, Actor performer, Actor target) {
  }

  static void defaultApplyHit (CombatMoveType move, Actor performer, Actor target, [String hitString]) {
    if (hitString == null)
      hitString = move.thirdPartyString;
    performer.report(hitString, object:target, positive:true);
    int actualDamage = Math.max(0, move.damage);
    target.hitpoints -= actualDamage;
    if (actualDamage == 0 && move.damage != 0)
      performer.report("it doesn't hurt <object>", object:target, but:true);
    target.stance -= move.stanceDamage;
    //if (target.currentMove != null && !target.currentMove.type.offensive)
    //  target.currentMove = null;
  }

  static void defaultApplyBlock (CombatMoveType move, Actor performer, Actor target) {
    target.report("<subject> block<s> <object's> ${move.string}", object:performer, positive:true);
    int actualStanceDamage = Math.max(
        0, 
        (move.stanceDamage / 2).toInt() - target.fighting
    );
    if (actualStanceDamage > 0) {
      target.report("the blow was hard", negative:true);
      target.stance -= actualStanceDamage;
    }
    //if (target.currentMove != null && !target.currentMove.type.offensive)
    //  target.currentMove = null;
  }

  static void defaultApplyDodge (CombatMoveType move, Actor performer, Actor target) {
    target.report("<subject> dodge<s> <object's> ${move.string}", object:performer, positive:true);
    //if (target.currentMove != null && !target.currentMove.type.offensive)
    //  target.currentMove = null;
  }

  static void defaultApplyCancel (CombatMoveType move, Actor performer, Actor target) {
    performer.report("there's no way <subject> can ${move.choiceString} now", object:target, negative:true);
  }

  static double defaultChanceToDodge (CombatMoveType move, Actor performer, Actor target) {
    return move.baseChanceToDodge; 
  }

  static double defaultChanceToBlock (CombatMoveType move, Actor performer, Actor target) {
    return move.baseChanceToBlock; 
  }

  static int defaultComputeSuitability (CombatMoveType move, Actor performer, Actor target) {
    if (move.offensive) {
      int value = move.damage + (move.stanceDamage / 5).toInt();
      value += ((1 - move.chanceToDodge(performer, target)) * (1 - move.chanceToBlock(performer, target)) * 10).toInt();
      if (performer.previousMove != null) // similar moves as the last one get minus points
        value -= countBits(move.type & performer.previousMove.type);
      return value;
    } else {
      return move.fightingMod;
    }
  }

  void initDefaultFunctions() { //TODO rename to init()
    on = new CombatEventHandler(this);

    applicable = (Actor performer, Actor target) {
      return defaultApplicable(this, performer, target);
    };

    canContinue = (Actor performer, Actor target) {
      return defaultCanContinue(this, performer, target);
    };

    start = (Actor performer, Actor target) {
      defaultStart(this, performer, target);
    };

    update = (Actor performer, Actor target) {
      defaultUpdate(this, performer, target);
    };

    applyEnd = (Actor performer, Actor target) {
      defaultApplyEnd(this, performer, target);
    };

    applyHit = (Actor performer, Actor target) {
      defaultApplyHit(this, performer, target);
    };

    applyBlock = (Actor performer, Actor target) {
      defaultApplyBlock(this, performer, target);
    };

    applyDodge = (Actor performer, Actor target) {
      defaultApplyDodge(this, performer, target);
    };

    applyCancel = (Actor performer, Actor target) {
      defaultApplyCancel(this, performer, target);
    };
   
    chanceToDodge = (Actor performer, Actor target) {
      return defaultChanceToDodge(this, performer, target);
    };

    chanceToBlock = (Actor performer, Actor target) {
      return defaultChanceToBlock(this, performer, target);
    };

    computeSuitability = (Actor performer, Actor target) {
      return defaultComputeSuitability(this, performer, target);
    };
  }


  CombatMoveType(Map<String,Dynamic> options) : super() {
    initDefaultFunctions();

    if (options != null) {
      type = options["type"] == null ? type : options["type"];
      string = options["string"] == null ? string : options["string"];
      choiceString = options["choiceString"] == null ? choiceString : options["choiceString"];
      thirdPartyString = options["thirdPartyString"] == null ? thirdPartyString : options["thirdPartyString"];
      duration = options["duration"] == null ? duration : options["duration"];
      recovery = options["recovery"] == null ? recovery : options["recovery"];
      damage = options["damage"] == null ? damage : options["damage"];
      stanceDamage = options["stanceDamage"] == null ? stanceDamage : options["stanceDamage"];
      baseChanceToBlock = options["baseChanceToBlock"] == null ? baseChanceToBlock : options["baseChanceToBlock"];
      baseChanceToDodge = options["baseChanceToDodge"] == null ? baseChanceToDodge : options["baseChanceToDodge"];
      fightingMod = options["fightingMod"] == null ? fightingMod : options["fightingMod"];
    }
  }


  // TODO: see http://en.wikipedia.org/wiki/Punch_(combat) for inspiration
  // http://www.eazycheezy.net/2010/04/how-to-throw-a-punch-by-guest-author-the-wolf.html
  CombatMoveType.Hand() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_TRG_BODY|MOVE_FRM_RIGHT|MOVE_LMB_HAND|MOVE_EFF_HITPOINTS|MOVE_PRI_QUICK|MOVE_DIR_OFFENSIVE;
    string = "hit to the stomach";
    choiceString = "hit <object> to the stomach";
    thirdPartyString = "<subject> hit<s> <object> to the stomach";
    duration = 4;
    recovery = 1;
    damage = 1;
    stanceDamage = 2;
    baseChanceToDodge = 0.1;
    baseChanceToBlock = 0.3;

    applicable = (Actor performer, Actor target) {
      if (performer.stance < 10)
        return false;
      return defaultApplicable(this, performer, target);
    };
  }

  CombatMoveType.Haymaker() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_TRG_HEAD|MOVE_FRM_RIGHT|MOVE_LMB_HAND|MOVE_EFF_HITPOINTS|MOVE_PRI_DAMAGE|MOVE_DIR_OFFENSIVE;
    string = "strike to the face";
    choiceString = "strike <object> with <subjectPronoun's> left hook";
    thirdPartyString = "<subject> strike<s> <object> with <subjectPronoun's> left hook";
    duration = 6;
    recovery = 1;
    damage = 2;
    stanceDamage = 8;
    baseChanceToDodge = 0.2;
    baseChanceToBlock = 0.2;
    fightingMod = -1;

    applicable = (Actor performer, Actor target) {
      if (performer.stance < 20)
        return false;
      if (target.stance < 10)
        return false;
      return defaultApplicable(this, performer, target);
    };

    applyHit = (Actor performer, Actor target) {
      performer.combat.storyline.add("Boom!", wholeSentence:true, positive:true);
      defaultApplyHit(this, performer, target, hitString:"<subject> hit<s> <object> in the face");
    };
  }

  CombatMoveType.Kick() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_TRG_LEGS|MOVE_FRM_RIGHT|MOVE_LMB_LEG|MOVE_EFF_STANCE|MOVE_PRI_DAMAGE|MOVE_DIR_OFFENSIVE;
    string = "kick to the legs";
    choiceString = "kick <object's> legs";
    thirdPartyString = "<subject> kick<s> <object's> legs";
    duration = 6;
    recovery = 2;
    damage = 0;
    stanceDamage = 15;
    baseChanceToDodge = 0.2;
    baseChanceToBlock = 0.2;
    fightingMod = -1;

    applicable = (Actor performer, Actor target) {
      if (performer.stance < 30 || target.stance < 20)
        return false;
      return defaultApplicable(this, performer, target);
    };

    applyHit = (Actor performer, Actor target) {
      defaultApplyHit(this, performer, target, hitString:"<subject> kick<s> <object's> legs");
    };
  }

  CombatMoveType.Defense() : super () {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_DIR_DEFENSIVE|MOVE_LMB_HAND;
    string = "parry";
    choiceString = "parry <object's> move";
    thirdPartyString = "<subject> parr<ies> <object's> move";
    duration = 4;
    recovery = 0;
    fightingMod = +2;

    applicable = (Actor performer, Actor target) {
      if (target.target != performer)
        return false; // don't parry attacks that don't target you
      if (target.currentMove == null 
          || (target.currentMove.type.damage == 0 && target.currentMove.type.stanceDamage == 0))
        return false; // don't parry no attack and don't parry someone parrying you
      return defaultApplicable(this, performer, target);
    };

    start = (Actor performer, Actor target) {
      if (target.isPlayer) {
        performer.report("<subject> braces for <object's> blow", object:target);
      } else if (performer.isPlayer) {
        performer.report("you decide to brace for <object's> blow", endSentence:true, object:target);
      }
      // wait for the blow
      performer.tillEndOfMove = target.tillEndOfMove + 1;
    };

    update = (Actor performer, Actor target) {
      performer.stance += 1;
    };
  }

  CombatMoveType.StandUp() : super () {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_DIR_DEFENSIVE|MOVE_LMB_LEG;
    string = "stand up";
    choiceString = "stand up";
    thirdPartyString = "<subject> stand<s> up";
    duration = 8;
    recovery = 0;
    fightingMod = -1;

    applicable = (Actor performer, Actor target) {
      return performer.stance < 20; // can only start standing up if not standing up already
    };

    update = (Actor performer, Actor target) {
      if (performer.tillEndOfMove <= (duration / 2).toInt()) // first few timesteps the actor is gathering - his stance doesn't rise yet
        performer.stance += 4;
    };

    start = (Actor performer, Actor target) {
      String again = (performer.previousMove == this) ? " again" : "";
      performer.report(randomly(["<subject> gather<s> to stand up$again", "<subject> begin<s> to stand up$again", "<subject> tr<ies> to stand up$again"]));
    };

    computeSuitability = (Actor performer, Actor target) {
      return 10; // when this move is applicable, it's probably a good idea to use it
    };
  }

  CombatMoveType.Withdraw() : super() {
    // init with defaults
    initDefaultFunctions();

    type = MOVE_DIR_DEFENSIVE|MOVE_LMB_LEG;
    string = "withdraw";
    choiceString = "take a step back";
    thirdPartyString = "<subject> take<s> a step back";
    duration = 5;
    recovery = 0;
    fightingMod = +1;

    applicable = (Actor performer, Actor target) {
      if (!performer.alive)
        return false;
      if (performer.stance < 20)
        return false;
      return true; 
    };

    start = (Actor performer, Actor target) {
      performer.report(randomly(["<subject> withdraw<s>", "<subject> back<s> away", "<subject> give<s> ground"]));
    };

    applyEnd = (Actor performer, Actor other) {
      performer.stance += 10;
    };
  }
}

class CurrentCombatMove extends GameEntity {
  CombatMoveType type;
  Actor performer;
  Actor target;

  CombatEventHandler on;

  CurrentCombatMove(this.type, [this.performer, this.target]) {
    on = new CombatEventHandler(this);
  }
}


class WeaponType extends GameEntity {
  int piercing;
  int hardness;
  Set<CombatMoveType> moves; // moves that make sense with this weapon TODO
  CombatEventHandler on;

  WeaponType([Map<String,Dynamic> options]) {
    on = new CombatEventHandler(this);

    if (options == null) {
      piercing = 0;
      hardness = 0;
    } else {
      piercing = options["piercing"] == null ? 0 : options["piercing"];
      hardness = options["hardness"] == null ? 0 : options["hardness"];
    }
  }

}

class ArmorType extends GameEntity {
  int hardness;
  CombatEventHandler on;

  ArmorType([Map<String,Dynamic> options]) {
    on = new CombatEventHandler(this);

    if (options == null) {
      hardness = 0;
    } else {
      hardness = options["hardness"] == null ? 0 : options["hardness"];
    }
  }
}

class CombatEvent {
  Queue<Function> functions;

  GameEntity _this;
  String _key;

  CombatEvent(this._this, this._key) {
    functions = new Queue<Function>();
  }

  void add(Function f) {
    functions.add(f);
  }
  void addFirst(Function f) {
    functions.addFirst(f);
  }
  void addLast(Function f) {
    functions.addLast(f);
  }

  Function get first() => functions.first();
  Function get last() => functions.last();

  void dispatchAll([Actor performer, Actor target]) {
    // if this is called from a currentMove, then apply currentMove's performer & target
    if (_this is CurrentCombatMove) {
      if (performer == null && target == null) {
        performer = _this.performer;
        target = _this.target;
      }
      // call this CurrentCombatMove's type EventHandler first
      _this.type.on[_key].dispatchAll(performer, target);
    }
    functions.forEach((func) {
        if (performer == null && target == null)
          func(_this);
        else if (target == null)
          func(_this, performer);
        else
          func(_this, performer, target);
    });
  }
}

/// Every object has "on" member of this class.
/// It's used like this: on.hit.add((performer, target) { ... });
/// Then fired with on.hit.dispatch();
class CombatEventHandler {

  // reference to the caller object
  GameEntity _this;

  // on.___ events are called by the Combat Object
  Map<String,CombatEvent> _events;

  CombatEvent operator [](String key) {
    if (_events.containsKey(key))
      return _events[key];
    else {
      _events[key] = new CombatEvent(_this, key);
      return _events[key];
    }
  }

  void operator []=(String key, CombatEvent value) {
    _events[key] = value;
  }

  CombatEventHandler(this._this) {
    _events = new Map<String,CombatEvent>();
  }
}


/// Events that can be started with start(event) and TIS takes care of the repetition.

interface LoopedEvent {
  bool finished;
  bool interactionNeeded;
  void start();
  void update();
  void updateUntilInteraction();
  List<Choice> playerChoices;
  Storyline storyline;
}


class Combat extends GameEntity implements LoopedEvent {
  Storyline storyline;

  static final int MAX_MOVES_PRESENTED = 5;

  bool _started = false;
  bool finished = false;
  bool interactionNeeded = false;

  CombatEventHandler on;

  int _prevTime = 0;
  int time = 0;

  void start() {
    actors.forEach((a) { 
        a.combat = this; 
        if (a.isPlayer)
          _player = a;
    });
    _started = true;
  }

  List<Actor> actors;
  Actor _player;
  List<Choice> playerChoices;

  Combat() : super() {
    storyline = new Storyline();
    actors = new List();
    playerChoices = new List();
    on = new CombatEventHandler(this);
  }

  /// The main function that gets called every single move and calls each actor to do their own stuff.
  void update() {
    // find out if time passed since last time update() was called
    bool timePassed = (time > _prevTime);
    _prevTime = time;

    if (timePassed) {
      this.on["update"].dispatchAll();

      actors.forEach((actor) {
        actor.update();
        actor.on["update"].dispatchAll();
      });

      // make sure the fight still needs to continue
      if (!actors.some((a) => a.alive && actors.some((b) => b.alive && b.team != a.team))) {
        finished = true;
        return;
      }
    }

    if (_player != null && _player.alive && _player.tillEndOfMove <= 0) {
      if (_player.target == null) {
        // let player choose his target
        List<Actor> possibleEnemies = actors.filter((o) => o.team != _player.team && o.alive);
        possibleEnemies.forEach((enemy) {
            playerChoices.add(new Choice("Target ${enemy.name}.", showNow:true, then:() { storyline.add("<subject> now lock on to <object>", subject:_player, object:enemy); _player.target = enemy; }));
        });
      } else {
        // find out possible moves the player can perform on the target
        List<CombatMoveType> possibleMoves = _player.getPossibleMoves(max:MAX_MOVES_PRESENTED);
        if (!possibleMoves.isEmpty()) {
          possibleMoves.sort((a,b) => a.type - b.type);
          possibleMoves.forEach((move) {
              playerChoices.add(new Choice(capitalize(Storyline.getString(move.choiceString, subject:_player, object:_player.target)), showNow:true, then:() { _player.currentMove = move; _player.currentMove.type.start(_player, _player.target); }));
          });
        }
        // let player target someone else
        if (actors.some((a) => a.alive && a != _player.target && a.team != _player.team))
          playerChoices.add(new Choice("Target another enemy.", showNow:true, then:() { _player.target = null; time--; })); 
      }

      if (!playerChoices.isEmpty()) {
        interactionNeeded = true;
      }
    }

    time++;
  }

  void updateUntilInteraction() {
    while (!finished && !interactionNeeded) {
      update();
    }
    interactionNeeded = false;  // reset for next run
  }
}

</classes>

<library>

void start(LoopedEvent event) {
  vars["_curLoopedEvent"] = event;
  vars["_curLoopedEventChoices"] = new List<Choice>();
  event.playerChoices = vars["_curLoopedEventChoices"];
  event.start();
  updateLoopedEvent();
}

void updateLoopedEvent() {
  LoopedEvent event = vars["_curLoopedEvent"];
  if (event.finished)
    return;
  event.playerChoices.clear();
  event.updateUntilInteraction();
  echo(event.storyline.toString());
  event.storyline.clear();
  choices.addAll(event.playerChoices);
  nextScript(updateLoopedEvent);
}

</library>
